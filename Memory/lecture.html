<title>CS360 Lecture notes -- Memory</title>
<body bgcolor=ffffff>
<h1> CS360 Lecture notes -- Memory</h1>
<LI> <a href=http://web.eecs.utk.edu/~plank>James S. Plank</a>
<LI> Directory: <b>/home/plank/cs360/notes/Memory</b>
<LI> Lecture notes:
    <a href=http://web.eecs.utk.edu/~plank/plank/classes/cs360/360/notes/Memory/lecture.html>
    <b>
  http://web.eecs.utk.edu/~plank/plank/classes/cs360/360/notes/Memory/lecture.html
</b></a>
<LI> Original Lecture Notes: Mid 1990's.
<LI> Most recent update: March, 2018

<hr>

<H1> Before I Start </h1>

(This was written in 2018.)
This lecture material can be problematic, because memory layout, and the primitives
used to explore them are typically not POSIX standards, and can differ from operating
system to operating system.  Fortunately, the concepts are easy to map from one machine to
another, but I can understand your frustration if things become confusing on a new machine.
<p>
Fortunately, Raspberry Pi's using the Raspbian operating system are pretty clean, 32-bit
machines.  The output that you see below will be on a Pi, so if you have access
to one and want to follow along, then please do so.  Most Linux OS's will come close to
what you see here, so long as you are ready for 64-bit pointers.  If you compile these
programs with <b>-32</b> on a 64-bit Linux machine, you'll get nicer looking pointers.
<p>

<hr>
<H1> Memory </h1>

This lecture is an introduction to memory as we see it in Unix.
<p>
<p>As I have said previously, memory is like a huge array with 
2<sup>32</sup> or 2<sup>64</sup> elements, depending on whether you are 
running in 32 or 64-bit mode.
A pointer in C is an index to this array.  Thus when 
a C pointer is <tt>0xefffe034</tt>, it points to the <tt>0xefffe035th</tt> element in 
the memory array (memory being indexed starting with zero).

<p>You cannot access all elements of memory.  One example
that we have seen a lot is element 0.  If you try to dereference a 
pointer with a value of 0, you will get a segmentation violation.
This is Unix's way of telling you that that memory location is
illegal.

<p>For example, the following program 
(<b><a href=segfault.c>segfault.c</a></b>)
will generate a segmentation violation.

<p><center><table border=3 cellpadding=3><td><pre>
int main()
{
  char *s;
  char c;

  s = (char *) 0;
  c = *s;           <font color=blue>/* The segmentation violation happens here. */</font>
  return 0;
}
</pre></td></table></center><p>

<pre>
UNIX> <font color=darkred><b>./segfault</b></font>
Segmentation fault
UNIX> <font color=darkred><b></b></font>
</pre>

There are many regions of memory that are set up to be legal, when you run your
program.  They are set up by the operating system, with the help of the hardware.
I will talk about four of them here.  While there are standard Unix names for 
them (which I'll tell you), I think that they are confusing, so I use my own:
<OL>
<LI><b>The code</b>: This memory region holds the instructions of your program.
The standard Unix name for this is "text".
<LI><b>The globals</b>: These are your global variables.  Standard Unix lingo splits the
globals into two parts: "Data", which holds global variables that have been initialized in
the program; and "BSS", which holds global variables that have not been initialized.
<LI><b>The heap</b>: This is memory that you get from <b>malloc()</b> (or <b>new</b> in C++).
<LI><b>The stack</b>: This contains your local variables and procedure arguments.
</OL>

If we view memory as a big array, the regions (or ``segments'') look
as follows:

<pre>
     |--------------| 0x00000000
     |              |
     |   void       |
     |              |
     |--------------| 
     |              |
     |  code        |
     |              |
     |--------------|
     |  void        |
     |--------------| 
     |              |
     |  globals     |
     |              |
     |--------------|
     |  void        |
     |--------------|
     |              |
     |  heap        |
     |              |  You can make the heap grow with the sbrk() or mmap() system call.
     |--------------|
     |  void        |
     |--------------|
     |              |
     |  stack       |
     |              | 
     |--------------|
     |  void        |
     |--------------| 0xffffffff
</pre>

Note, the heap grows down as you make more <b>malloc()</b> calls and your program
asks the operating system for more memory.  As we have seen in the Assembly code
lecture notes, the stack grows "upward", by subtracting values from the stack and frame
pointers.  In reality, the stack is a fixed size (typically 8 MB).  You could make it
grow by using <b>mmap()</b> properly, but that is not what happens by default.

<hr>
<h1>Paging</h1>

On all machines, memory is broken up into fixed chunks called pages.
Pages are typically 4096 or 8192 bytes long, but other sizes have been supported
by other machines.  You can find out your machine's page size by calling
the <b>getpagesize()</b> system call.  On the Pi, they are 4096 bytes (we
will see this below).

<p>
The way memory works is as follows:  The operating system allocates
certain pages of memory for you.  Whenever you try to read, write or execute
an instruction 
from an address in memory, the hardware first checks with the operating
system to see if that address belongs to a page that has been allocated
for you, and if you have permission to do the operation.  
If so, then it goes ahead and performs the read/write.  If
not, you'll get a segmentation violation, which is a hardware error.  It is caught
by the operating system, which in turn "sends" it to your program (we'll see how
you can "catch" it later in the semester).

<p>This is what happens when you do:

<pre>
  s = (char *) 0;
  c = *s;
</pre>

When you say "<b>c = *s</b>", the hardware sees that you
want to read memory location zero.  The hardware checks a table, which has been set up
by the operating system, to see if location zero is legal, and discovers that it
is not.  This results in a segmentation violation.  

<p>The exact mechanics of paging are covered in
classes on Operating Systems.  I won't go into them
further here.  What you should understand is that the hardware and operating system
manage memory at a page granularity, and that when you want to use memory, to read it, 
write it, or execute instructions from it, the hardware checks the page on which the
memory resides, to make sure you have the permissions to use it.  If you don't, you'll
get a segmentation violation.

<hr>
<h1>Looking at Memory Regions of your Program</h1>

The program 
<b><a href=look_at_memory.c>look_at_memory.c</a></b>
takes a look at the various memory regions of your program, while it is running.

<p><center><table border=3 cellpadding=3><td valign=top><pre>
#include &lt;sys/types.h&gt;
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;unistd.h&gt;

typedef unsigned long int UI;

<font color=blue>/* These are special variables that
   denote the end of the memory segments
   for the code ("text"), initialized
   global variables ("data") and
   uninitialized global variables ("bss").
   */</font>

extern end;
extern etext;
extern edata;

<font color=blue>/* Here are four global variables.  A
   and B belong to the "data", and X and Y
   belong to the "bss".  */</font>

int A = 4;
int X;
int B = 6;
int Y;

<font color=blue>/* Proc_a and main should reside in the
   "text" segment. */</font>

void proc_a()
{
}

<font color=blue>/* And of course i and buf will belong
   on the stack.  I will call malloc()
   to set buf equal to an address in 
   the heap. */</font>
</pre></td><td valign=top><pre>
int main(int argc, char **argv)
{
  int i;
  char *buf;

  buf = (char *) malloc(200);

  printf("Page size: %d\n", getpagesize());
  printf("\n");

  printf("&etext: 0x%lx\n", (UI) &etext);
  printf("&edata: 0x%lx\n", (UI) &edata);
  printf("&end:   0x%lx\n", (UI) &end);
  printf("\n");

  printf("Code Addresses:\n");
  printf("main:   0x%lx\n", (UI) main);
  printf("proc_a: 0x%lx\n", (UI) proc_a);
  printf("\n");

  printf("Global Variable Addresses:\n");
  printf("&A: 0x%lx\n", (UI) &A);
  printf("&B: 0x%lx\n", (UI) &B);
  printf("&X: 0x%lx\n", (UI) &X);
  printf("&Y: 0x%lx\n", (UI) &Y);
  printf("\n");

  printf("Heap Address:\n");
  printf("buf: 0x%lx\n", (UI) buf);
  printf("\n");

  printf("Stack Addresses:\n");
  printf("&i:    0x%lx\n", (UI) &i);
  printf("&buf:  0x%lx\n", (UI) &buf);
  printf("&argc: 0x%lx\n", (UI) &argc);
  printf("\n");

  <font color=blue>/* Finally, print the addressses as 
     recorded in the directory "/proc". */</font>

  sprintf(buf, "cat /proc/%d/maps", getpid());
  system(buf);
  return 0;
}
</pre></td></table></center><p>

Again, not all machines will allow this code to compile.  Linux-based machines are a pretty
safe bet, though.  Go ahead and read the comments to the code above.  Basically, we are 
printing out addresses of variables in each of the memory segments that I describe above.
After that, we look at the file <b>/proc/<i>pid</i>/maps</b>, which lets you know
about the memory mappings in the process with id <i>pid</i>.  

<p>
We run the program on a Raspberry Pi, and we get a lot of information:

<pre>
UNIX> <font color=darkred><b>./look_at_memory</b></font>
Page size: 4096

&etext: 0x107f4
&edata: 0x20a74
&end:   0x20a80

Code Addresses:
main:   0x1058c
proc_a: 0x10578

Global Variable Addresses:
&A: 0x20a6c
&B: 0x20a70
&X: 0x20a78
&Y: 0x20a7c

Heap Address:
buf: 0x12cb008

Stack Addresses:
&i:    0x7ebe3b3c
&buf:  0x7ebe3b38
&argc: 0x7ebe3b34

00010000-00011000 r-xp 00000000 00:22 126617690  /mnt/nfs/plank/cs360-lecture-notes/Memory/look_at_memory
00020000-00021000 rw-p 00000000 00:22 126617690  /mnt/nfs/plank/cs360-lecture-notes/Memory/look_at_memory
012cb000-012ec000 rw-p 00000000 00:00 0          [heap]
76d9c000-76ec7000 r-xp 00000000 b3:07 524518     /lib/arm-linux-gnueabihf/libc-2.19.so
76ec7000-76ed7000 ---p 0012b000 b3:07 524518     /lib/arm-linux-gnueabihf/libc-2.19.so
76ed7000-76ed9000 r--p 0012b000 b3:07 524518     /lib/arm-linux-gnueabihf/libc-2.19.so
76ed9000-76eda000 rw-p 0012d000 b3:07 524518     /lib/arm-linux-gnueabihf/libc-2.19.so
76eda000-76edd000 rw-p 00000000 00:00 0 
76ef6000-76efb000 r-xp 00000000 b3:07 3540510    /usr/lib/arm-linux-gnueabihf/libarmmem.so
76efb000-76f0a000 ---p 00005000 b3:07 3540510    /usr/lib/arm-linux-gnueabihf/libarmmem.so
76f0a000-76f0b000 rw-p 00004000 b3:07 3540510    /usr/lib/arm-linux-gnueabihf/libarmmem.so
76f0b000-76f2b000 r-xp 00000000 b3:07 524429     /lib/arm-linux-gnueabihf/ld-2.19.so
76f35000-76f3a000 rw-p 00000000 00:00 0 
76f3a000-76f3b000 r--p 0001f000 b3:07 524429     /lib/arm-linux-gnueabihf/ld-2.19.so
76f3b000-76f3c000 rw-p 00020000 b3:07 524429     /lib/arm-linux-gnueabihf/ld-2.19.so
7ebc3000-7ebe4000 rwxp 00000000 00:00 0          [stack]
7ec2a000-7ec2b000 r-xp 00000000 00:00 0          [sigpage]
7ec2b000-7ec2c000 r--p 00000000 00:00 0          [vvar]
7ec2c000-7ec2d000 r-xp 00000000 00:00 0          [vdso]
ffff0000-ffff1000 r-xp 00000000 00:00 0          [vectors]
UNIX> <font color=darkred><b></b></font>
</pre>

From this program, we can deduce that our program's address space looks as in the picture below:

<p><center><table border=3><td><img src=Drawings.jpg></td></table></center><p>

You'll note that every memory address from <tt>0x0</tt. to <tt>0xffffffff</tt> is accounted
for.  You'll also note how the <b>printf()</b> statements from the program match the 
picture.  For example, <b>A</b> and <b>B</b> have values between <tt>0x20000</tt>
(the beginning of the globals) and <tt>0x20ffff</tt>.  They also have values lower than
<b>&amp;edata</b>, which is right, because they are initialized by the program.
<p>
<b>X</b> and <b>X</b> also have values between <tt>0x20000</tt>
and <tt>0x20ffff</tt>.  They are uninitialized, so they belong in the "bss" segment.
Accordingly, their values are between <b>&amp;edata</b> and 
<b>&amp;end</b>.
<p>
You should also see that <b>main</b> and <b>proc_a</b> are in the code segment, 
<b>buf</b> is in the heap, and <b>&amp;i</b>, <b>&amp;buf</b> and <b>&amp;argc</b> are
all in the code segment.  
<p>
All of the addresses labeld <b>NULL</b> will give you segmentation violations if you 
try to access them.
<p>
It is slightly unfortunate that the heap and stack addresses will change from run to run:

<pre>
UNIX> <font color=darkred><b>./look_at_memory | grep buf</b></font>
buf: 0x53b008
&buf:  0x7e98eb38
UNIX> <font color=darkred><b>./look_at_memory | grep buf</b></font>
buf: 0x1274008
&buf:  0x7efc4b38
UNIX> <font color=darkred><b>./look_at_memory | grep buf</b></font>
buf: 0x19df008
&buf:  0x7eec7b38
UNIX> <font color=darkred><b></b></font>
</pre>

The reason for this is security.  Be ready for it.

<hr>
<font color=red>Still writing the rest of this -- what is below is stale.</font>

Whenever you call a procedure, it allocates local
variables and arguments (plus a few other things)
on the stack.  Whenever you return from a
procedure, those varables are popped off the
stack.  So, look at 
<a href=testaddr4.c><b>testaddr4.c</b></a>.  
It has <b>main()</b>
call itself recursively as many times as there are
arguments.  You'll see that at each recursive
call, the addresses of <b>argc</b> and <b>argv</b> and the
local variable <b>i</b> are smaller addresses -- this is because
each time the procedure is called, the stack
grows upward to allocate its arguments and
local variables.  You've seen this already in the assembler
lectures.

<pre>
UNIX> <b>testaddr4</b>
argc = 1.  &argc = 0xffbee15c, &argv = 0xffbee160, &i = 0xffbee104
argc = 0.  &argc = 0xffbee0e4, &argv = 0xffbee0e8, &i = 0xffbee08c
UNIX> <b>testaddr4 v</b>
argc = 2.  &argc = 0xffbee154, &argv = 0xffbee158, &i = 0xffbee0fc
argc = 1.  &argc = 0xffbee0dc, &argv = 0xffbee0e0, &i = 0xffbee084
argc = 0.  &argc = 0xffbee064, &argv = 0xffbee068, &i = 0xffbee00c
UNIX> <b>testaddr4 v o l s</b>
argc = 5.  &argc = 0xffbee144, &argv = 0xffbee148, &i = 0xffbee0ec
argc = 4.  &argc = 0xffbee0cc, &argv = 0xffbee0d0, &i = 0xffbee074
argc = 3.  &argc = 0xffbee054, &argv = 0xffbee058, &i = 0xffbedffc
argc = 2.  &argc = 0xffbedfdc, &argv = 0xffbedfe0, &i = 0xffbedf84
argc = 1.  &argc = 0xffbedf64, &argv = 0xffbedf68, &i = 0xffbedf0c
argc = 0.  &argc = 0xffbedeec, &argv = 0xffbedef0, &i = 0xffbede94
UNIX> <b></b>
</pre>

Now, lets break the stack.  This can be done by writing a program 
that allocates too much stack memory.  One such program is in 
<a href=breakstack1.c><b>breakstack1.c</b></a>.  
It performs infinite recursion, and at each recursive step it allocates
10000 bytes of stack memory in the variable <b>iptr</b>.  When you run this,
you'll see that you get a segmentation violation when the recursive
call is made and the stack is about to dip below 0xff3f0000:

<pre>
UNIX> <b>breakstack1</b>
...
&c     = 0xff3fa347, iptr = 0xff3f7c30  ...  ok
&c     = 0xff3f7bbf, iptr = 0xff3f54a8  ...  ok
&c     = 0xff3f5437, iptr = 0xff3f2d20  ...  ok
Segmentation Fault
UNIX> 
</pre>

Often when you have infinite recursion and overflow the
stack, you get "illegal instruction" instead of Segmenation fault.
I can't explain this in detail-- just be ready for it...

<p>The second way to break the stack is to simply allocate too much local
memory.  E.g. look at 
<a href=breakstack2.c><b>breakstack2.c</b></a>.  
It tries to allocate 10M of memory
in the stack.   It segfaults in <b>a</b> because it tries to 
reference smaller memory addresses than 0xff3f0000.  Exactly where
does the seg fault happen?  Think about it -- answer below.
<p>
The segfault happens in <b>a</b> when the code attempts to push
<b>iptr</b> on the stack for the <b>printf</b> call.  This is because
the stack pointer is pointing to the void.  Had we not referenced
anything at the stack pointer, our program should have worked.  For
example, try 
<a href=breakstack3.c><b>breakstack3.c</b></a>.  
<pre>
UNIX> <b>breakstack3</b>
Calling a.  i = 1
After a is done.  i = 5
UNIX> 
</pre>
You should understand, and be able to explain this phenomenon.

