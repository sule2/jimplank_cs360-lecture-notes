<title> Getting Started with C, Types, Pointers, Casting, Malloc, Segmentation Violations and Bus Errors</title>
<body bgcolor=FFFFFF>
<h2> Getting Started with C, Types, Pointers, Casting, Malloc, Segementation Violations and Bus Errors</h2>

<UL>
<LI> <a href=http://web.eecs.utk.edu/~plank>James S. Plank</a>
<LI> <a href=http://web.eecs.utk.edu/~plank/plank/classes/cs360/>CS360</a>
<LI> Url: <a href=http://web.eecs.utk.edu/~plank/plank/classes/cs360/360/notes/CStuff/lecture.html><b>
                  http://web.eecs.utk.edu/~plank/plank/classes/cs360/360/notes/CStuff/lecture.html</b></a>
<LI> Programs are on the UT lab machines at <b>~plank/cs360/notes/CStuff</b>
<LI> And bitbucket: <a href=https://bitbucket.org/jimplank/cs360-lecture-notes>https://bitbucket.org/jimplank/cs360-lecture-notes</a>.
<LI> Originally written in 1995.
<LI> Last modification: <i>
Wed Jan 10 16:47:39 EST 2018
</i>
</UL>
<hr>

<h2>Moving from C++ to C</h2>

This class is taught in C, rather than C++.  The reasoning is as follows:
Because C hides so much
less from you than C++, you have a much easier time figuring out what's 
going on when you run one or more programs.  This will be a little painful,
because you lose so many of the wonderful things about C++ on which you have
grown to rely, like <b>cin</b>, strings, objects with methods, and the standard
template library.  Sorry.  
<p>
These lecture notes detail the parts of C++ that you lose when you migrate
to C, and how you replace them.
<p>
You have to use <b>gcc</b> to compile programs in this class.  You <i>cannot</i>
use <b>g++</b>.  Don't give the TA's C++ code and say you didn't know.  You know.
<p>
Time to learn C.
<hr>
<h2>Header files</h2>
As with C++, you include standard header files with <b>#include</b>.  You include
the file name in less-than/greater-than signs, and you include the <b>.h</b> extension.
Instead of starting your programs with:
<p><center><table border=3 cellpadding=3><td><pre>
#include &lt;iostream&gt;
using namespace std;
</pre></td></table></center><p>
you start them with:
<p><center><table border=3 cellpadding=3><td><pre>
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
</pre></td></table></center><p>
I never liked that "using namespace std" stuff anyway.
<hr>
<h2>Comments</h2>

Comments in C are delimited by "/*" and "*/".  The former starts the comment, which 
can span multiple lines, and the latter ends the comment.   (C++ style commenting 
has been added to the C standard, so you can use it, but I don't -- you never know when
you're going to be running on that 1979 VM....)
<hr>

<h2>Bye-bye, cin and cout</h2>

Frankly, this isn't too painful, and will be less so when you learn the fields library.
I'm assuming that you already know <b>printf()</b> from previous classes.  
That handles output.  
For input, we'll focus on three procedures that are defined
in <b>stdio.h</b>: <b>scanf()</b>, <b>fscanf()</b> and <b>fgets()</b>.
We'll get to <b>scanf()</b> a little later in the lecture.




<hr>
<h2>Types in C</h2>

In C, there are three kinds of types that variables can have -- scalars, 
      aggregates, and pointers.  Half of the game in getting things right
      in C is keeping yourself from being confused about types.  This lecture
      tries to elaborate on this a little.

<h2>Scalar Types</h2>

There are 7 scalar types in C:

<LI> <b>char</b>       -- 1 byte
<LI> <b>short</b>      -- 2 bytes
<LI> <b>int</b>        -- 4 bytes
<LI> <b>long</b>       -- 4 or 8 bytes, depending on the system and compiler
<LI> <b>float</b>      -- 4 bytes
<LI> <b>double</b>     -- 8 bytes
<LI> (pointer    -- 4 or 8 bytes, depending on the system and compiler)
<p>
These should all be familiar to you (ok, maybe not a <b>short</b>, but the rest should).  
If you want to verify or use the size of a type in C, you use the macro <b>sizeof()</b>.
For example, <b>sizeof(long)</b> will return either 4 or 8, depending on how big a <b>long</b>
is in your system.
<p>
You can declare a scalar variable in 
one of three places:  As a global variable, as a procedure parameter, and 
as a local variable.  For example, look at the program below in 
<a href=p1.c><b>p1.c</b></a>:
<p>
(In this and all other lecture notes, you can copy the programs and the
makefile into your own directory, and then compile them by using <b>make</b>.
E.g. to make the program <b>p1</b>, you say ``<b>make p1</b>'').

<p><center><table border=3 cellpadding=3><td><pre>
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

int i;

int main(int argc, char **argv)
{
  int j;

  j = argc;
  i = j;
  printf("Argc:          %d\n", i);

  j = sizeof(long);
  printf("Sizeof(long):  %d\n", j);

  j = sizeof(int *);
  printf("Sizeof(int *): %d\n", j);

  exit(0);
}
</pre></td></table></center><p>

There are three scalar int variables here -- <b>i</b>, <b>j</b>, and 
<b>argc</b>.  <b>I</b> is a global 
variable.  <b>J</b> is a local variable, and <b>argc</b> 
is a parameter.  Scalars are 
pretty straightforward.   You can pass them as parameters to procedures, and 
return them from procedures without worrying about anything going awry.  

The program prints argc (which it has copied to the variables j and i), and then
the size of longs and pointers.  Here are two runs on my Mac (in 2018).  As 
you can see, longs and pointers are 8 bytes:

<pre>
UNIX> <font color=darkred><b>./p1</b></font>
Argc:          1
Sizeof(long):  8
Sizeof(int *): 8
UNIX> <font color=darkred><b>./p1 using many arguments</b></font>
Argc:          4
Sizeof(long):  8
Sizeof(int *): 8
UNIX> <font color=darkred><b></b></font>
</pre>

Some machines allow you to compile in 32-bit mode, which forces pointers and longs to 
be four bytes.  On my macintosh, that's the "-m32" option to <b>gcc</b>:

<pre>
UNIX> <font color=darkred><b>gcc -m32 -o p1-32 p1.c</b></font>
UNIX> <font color=darkred><b>./p1-32</b></font>
Argc:          1
Sizeof(long):  4
Sizeof(int *): 4
UNIX> <font color=darkred><b></b></font>
</pre>

Some machines don't have 8-byte longs or pointers.  One example is the Raspberry Pi.
When I pulled the repo and compiled on my Pi, I got the following:

<pre>
pi@raspberrypi:~/CS360/cs360-lecture-notes/CStuff$ <font color=darkred><b>./p1</b></font>
Argc:          1
Sizeof(long):  4
Sizeof(int *): 4
pi@raspberrypi:~/CS360/cs360-lecture-notes/CStuff$ 
</pre>

The Pi's compiler doesn't have the "-m32" option.  Such is life.

<hr>
<h2>Aggregate Types</h2>

Arrays and structs are aggregate types in C.  They are more complex than 
scalars.  You can statically declare an array as a global or local variable --
I do both below in 
<b><a href=p2.c>p2.c</a></b>:

<p><center><table border=3 cellpadding=3><td><pre>
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

char s1[15];

int main(int argc, char **argv)
{
  char s2[4];

...
</pre></td></table></center><p>
<b>S1</b> is a global array of 15 chars and 
<b>s2</b> is a local array of 4 chars.  
<p>
If an array has been statically declared, then you cannot assign it to 
another array.  For example, look at the rest of <a href=p2.c><b>p2.c</b></a>:

<p><center><table border=3 cellpadding=3><td><pre>
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

char s1[15];

int main(int argc, char **argv)
{
  char s2[4];
  
  s2 = "Jim";
  exit(0);
}
</pre></td></table></center><p>

The statement ``<b>s2 = "Jim"</b>'' is illegal in C, because <b>s2</b> has 
been statically 
declared.  If you try to compile this program, <b>gcc</b> 
will give you an error:
<pre>
UNIX> <font color=darkred><b>gcc -o p2 p2.c</b></font>
p2.c: In function `main':
p2.c:10: incompatible types in assignment
UNIX>
</pre>
This is a good rule to bear in mind -- if <b>x</b> 
is an array, then you should <i>NEVER</i> say 
``<b>x = <i>something</i></b>''.  It
will usually give you an error.  However, if it doesn't (because they change
the compiler yet again), you are writing bad C code.
<p>
However, you can always say ``<b><i>something</i> = x</b>''.  We'll discuss later in the 
lecture.
<p>

When you 
<hr>
<h3>Structs</h3>

The second way to aggregate data is with a <b>struct</b>.  A <b>struct</b> looks a little
like a C++ class with some notable omissions:
<UL>
<LI> No "public/protected/private" mess.
<LI> No constructors/destructors.
<LI> No default "copy" methods or any of that mess.
<LI> No methods.
</UL>

Suppose we want to aggregate an int and a double.  We can do that as in 
<b><a href=id1.c>id1.c</a></b>

<p><center><table border=3 cellpadding=3><td><pre>
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

struct intdouble {
  int i;
  double d;
};

int main()
{
  struct intdouble id1;

  id1.i = 5;
  id1.d = 3.14;

  printf("%d %.2lf\n", id1.i, id1.d);
  exit(0);
}
</pre></td></table></center><p>


<pre>
UNIX> <font color=darkred><b>./id1</b></font>
5 3.14
UNIX> <font color=darkred><b></b></font>
</pre>

You can use a <b>typedef</b> to make it a little more readable (<b><a href=id2.c>id2.c</a></b>):

<p><center><table border=3 cellpadding=3><td><pre>
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

typedef struct intdouble {
  int i;
  double d;
} ID;

int main()
{
  ID id1;

  id1.i = 5;
  id1.d = 3.14;

  printf("1: %d %.2lf\n", id1.i, id1.d);
  exit(0);
}
</pre></td></table></center><p>

You may have some confusion with structs, because they exist in C++ with different
semantics.  Let's take a look at the following code in C++, which declares two
<b>intdouble</b>'s, sets one's variables, and then copies one to the other (<b><a href=id3.cpp>id3.cpp</a></b>):

<p><center><table border=3 cellpadding=3><td><pre>
#include &lt;cstdio&gt;
#include &lt;iostream&gt;
using namespace std;

struct intdouble {
  int i;
  double d;
};

int main()
{
  intdouble id1, id2;

  id1.i = 5;
  id1.d = 3.14;

  id2 = id1;
  id2.i += 5;
  id2.d += 5;

  printf("1: %d %.2lf\n", id1.i, id1.d);
  printf("2: %d %.2lf\n", id2.i, id2.d);
}
</pre></td></table></center><p>

Straightforward when it runs:

<pre>
UNIX> <font color=darkred><b>./id3</b></font>
1: 5 3.14
2: 10 8.14
UNIX> <font color=darkred><b></b></font>
</pre>


Let's change this to C.  If we simply fix the headers, this will not compile.
That is because C++ creates 
"intdouble" as a type, and C does not.  When we try to compile, it fails:

<pre>
UNIX> <font color=darkred><b>gcc -o id4 id4.c</b></font>
id4.c: In function 'main':
id4.c:11: error: 'intdouble' undeclared (first use in this function)
id4.c:11: error: (Each undeclared identifier is reported only once
id4.c:11: error: for each function it appears in.)
id4.c:11: error: expected ';' before 'id1'
id4.c:13: error: 'id1' undeclared (first use in this function)
id4.c:16: error: 'id2' undeclared (first use in this function)
UNIX> <font color=darkred><b></b></font>
</pre>

Now, if you put "struct" in front of "intdouble," that will fix the 
problem.  It is in
<b><a href=id5.c>id5.c</a></b>:

<p><center><table border=3 cellpadding=3><td><pre>
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

struct intdouble {
  int i;
  double d;
};

int main()
{
  struct intdouble id1, id2;

  id1.i = 5;
  id1.d = 3.14;

  id2 = id1;  <font color=blue>/* THIS IS THE OFFENDING LINE */</font>
  id2.i += 5;
  id2.d += 5;

  printf("1: %d %.2lf\n", id1.i, id1.d);
  printf("2: %d %.2lf\n", id2.i, id2.d);
  exit(0);
}
</pre></td></table></center><p>

This runs identically to the C++ version.  I can tell you that I disapprove of 
this code.  Why? Because the statement ``<b>id2 = id1</b>'' offends me.  It is the 
only part of C where you can copy an unspecified number of bytes with an assignment
statement.  It is a weakness of the language.  For example, take a look at
<b><a href=id5a.c>id5a.c</a></b>:

<p><center><table border=3 cellpadding=3><td><pre>
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

typedef struct {
  int a[1000];
} SID;

int main()
{
  SID s1, s2;
  int i;

  for (i = 0; i &lt; 1000; i++) s1.a[i] = i;
  s2 = s1;

  for (i = 0; i &lt; 1000; i++) printf("%4d %4d\n", s1.a[i], s2.a[i]);
 
  exit(0);
}
</pre></td></table></center><p>

The ``<b>s2 = s1</b>'' line copies 4000 bytes.  While I expect such garbage in C++,
I am surprised that it's legal in C.  Why does it allow you to copy the struct, but
not to copy the array?  Who knows -- anyway, I want you to be aware of it.
You will never see me use that feature of the language because I don't approve.

As a corollary, you can pass a struct as an argument to a procedure, and in C++
fashion, it makes a copy of the entire thing.  You'll note that in 
<b><a href=id5b.c>id5b.c</a></b>, I define a procedure <b>a()</b>, which changes the
last element of the array, and when we run it, <b>s1.a[999]</b> is unchanged.  
Make a mental note of it.

<p><center><table border=3 cellpadding=3><td><pre>
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

typedef struct {
  int a[1000];
} SID;

void a(SID s)    <font color=blue>/* Although this procedure changes element 999 of s, */</font>
{                <font color=blue>/* s is a copy of the calling parameter, so it is    */</font>
  s.a[999] = -1; <font color=blue>/* deleted at the end of the procedure.              */</font>
}                <font color=blue>/* In other words, the procedure does nothing.       */</font>


int main()
{
  SID s1, s2;
  int i;

  for (i = 0; i &lt; 1000; i++) s1.a[i] = i;
  s2 = s1;

  a(s1);
  for (i = 0; i &lt; 1000; i++) printf("%4d %4d\n", s1.a[i], s2.a[i]);
 
  exit(0);
}
</pre></td></table></center><p>


<pre>
UNIX> <font color=darkred><b>./id5b | tail</b></font>
 990  990
 991  991
 992  992
 993  993
 994  994
 995  995
 996  996
 997  997
 998  998
 999  999
UNIX> <font color=darkred><b></b></font>
</pre>

<p>
A final note about C++ structs.  They are basically stripped down classes -- you 
can put methods in them, and then implement the methods using the struct's variables,
as in <b><a href=id6.cpp>id6.cpp</a></b>:

<p><center><table border=3 cellpadding=3><td valign=top><pre>
#include &lt;cstdio&gt;
#include &lt;iostream&gt;
using namespace std;

struct intdouble {
  int i;
  double d;
  void Print();
};

void intdouble::Print()
{
  printf("   %d %.2lf\n", i, d);
}
</pre></td><td valign=top><pre>
int main()
{
  intdouble id1, id2;

  id1.i = 5;
  id1.d = 3.14;

  id2 = id1;
  id2.i += 5;
  id2.d += 5;

  id1.Print();
  id2.Print();
}
</pre></td></table></center><p>

Whoever designed structs in C++ did the world a disservice, because you have the same
constructs in two fairly similar languages that have completely different semantics.
Which means that tons of people are going to be confused going from C++ to C, or 
even C to C++ when their struct semantics are off.  It is for this reason that
I don't teach structs as a C++ construct in either CS140 or CS302.  Just use
a class.  
<p>
<i>(When your job interviewer asks you why you are using classes rather than 
structs in C++, you should respond as follows: "Structs in C++ are totally different
constructs than they are in C.  However, they have enough similarity that one can
easily get confused when writing code in both languages.  For that reason, I choose
to use structs in C, but not in C++.  In C++, I use a class.  The compiler should
be smart enough to make the class code as efficient as struct code.")</i>

<hr>
<h2>Pointers</h2>

Pointers are where most people mess up in C.  A pointer is simply a
index to memory.  Memory can be allocated in one of two ways -- by
declaring variables, or by calling <b>malloc()</b> (there is no <b>new</b> in C).  
Whenever memory has been allocated, you can set a pointer to it.
<p>
You can view memory as one huge array of bytes (chars).  This array has
2<sup>32</sup> or 2<sup>64</sup> elements.  
Usually, we consider the indices to this array in 
hexadecimal.  In other words, the array goes from <b>0x0</b> to 
<b>0xffffffff</b> (or <b>0xffffffffffffffff</b>).
<p>
A pointer is simply an index of this array.  Whenever we allocate <i>x</i> bytes
of memory, we are reserving <i>x</i> contiguous elements from the memory array.
If we set a pointer to these bytes, then that pointer will be the index
of the first allocated byte in memory.
<p>
For example, look at the following program (in 
<a href=p3.c><b>p3.c</b></a>):

<p><center><table border=3 cellpadding=3><td><pre>
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

int main()
{
  int i;
  char j[14];
  int *ip;
  char *jp;

  ip = &i;
  jp = j;

  printf("ip = 0x%lx.  jp = 0x%lx\n", ip, jp);
  exit(0);
}
</pre></td></table></center><p>

This program allocates one integer (<b>i</b>), an array of 14 characters 
(<b>j</b>), and
two pointers (<b>ip</b> and <b>jp</b>).  
It then sets the pointers so that they point to
the memory allocated for <b>i</b> and <b>j</b>.  Finally, 
it prints out the values of those
pointers -- these are indices into the memory array.  
<p>
Unfortunately, when we try to compile this, we get warnings.  Don't worry
about them yet -- we'll get to that.  It still compiles correctly.
<p>
When we run it, we get the following (this was on my Mac in 2015)
<pre>
UNIX> <font color=darkred><b>./p3</b></font>
ip = 0x7fff2efcdd9c.  jp = 0x7fff2efcdda0
UNIX> <font color=darkred><b></b></font>
</pre>
What this means is that when we view memory as an array, elements
<b>0x7fff2efcdd9c</b>, <b>0x7fff2efcdd9d</b>, <b>0x7fff2efcdd9e</b>, 
and <b>0x7fff2efcdd9f</b> are allocated for
the local variable <b>i</b>, and elements <b>0x7fff2efcdda0</b> 
through <b>0x7fff2efcddad</b>
are allocated for the array <b>j</b>.  When you run this on your own machine,
you will get different pointer values.  Regardless of the pointer values,
<b>ip</b> will point to the first of the four bytes of <b>i</b>, and 
<b>ip</b> will point to the first of the fourteen bytes of <b>j</b>, and 
<p>
Note that I said ``<b>jp = j</b>'' and not ``<b>jp = &j</b>''.  
This is because when 
treated as an expression, an array is equivalent to a pointer.  The only
difference is that you cannot assign a value to an array variable.  Thus,
you can say ``<b>jp = j</b>'', but you cannot say ``<b>j = jp</b>''.  
Moreover, you cannot
take the address of an array variable -- saying ``<b>&j</b>'' is illegal. 
<p>
Pointers are a little like scalars -- they too can be declared as globals, 
locals or parameters, and can be assigned values, passed as parameters, and 
returned from procedures.  On our lab machines, pointers are 8 bytes.  Thus,
in <b>p3.c</b>, there are 34 bytes of local variables allocated in the 
<b>main()</b>
procedure -- 4 for <b>i</b>, 14 for <b>j</b>, 
8 for <b>ip</b>, and 8 for <b>jp</b>.
<p>
One of the nice things about 32-bit machines is that their pointers don't
seem so unwieldy.  On my Pi, the output is:

<pre>
pi@raspberrypi:~/CS360/cs360-lecture-notes/CStuff$ UNIX> <font color=darkred><b>.p3</b></font>
ip = 0x7eeb050c.  jp = 0x7eeb04fc
pi@raspberrypi:~/CS360/cs360-lecture-notes/CStuff$ 
</pre>

That feels more manageable, doesn't it?  

<hr>
<h2>Type Casting (sometimes called ``type coercion'')</h2>

There are times when you would like
to take a variable that is stored in <i>x</i> bytes, and assign them to 
a variable that is stored in <i>y</i> bytes.  This is called ``type casting''.  A simple
example is when you want to turn a <b>char</b> into an <b>int</b>, 
or an <b>int</b> into a <b>float</b> as in 
<a href=p4.c><b>p4.c</b></a>:

<p><center><table border=3 cellpadding=3><td><pre>
int main()
{
  char c;
  int i;
  float f;

  c = 'a';
  i = c;
  f = i;
  printf("c = %d (%c).   i = %d (%c).  f = %f\n", c, c, i, i, f);
  exit(0);
}
</pre></td></table></center><p>

The statement `<b>i = c</b>' is a type cast, as is the statement `<b>f = i</b>'.
<p>
Some type castings, like the one above, are very natural.  The C compiler 
will do these for you without complaining.  For most others, the C
compiler will spit out a warning, unless you specifically tell it that you are
doing a type cast (this is a way of telling the compiler ``Yes, I know 
what I'm doing.'').  
<p>
An example is program 
<b><a href=p3.c>p3.c</a></b> above -- as mentioned, when we compile it, we
get warnings:

<pre>
UNIX> <font color=darkred><b>make p3</b></font>
gcc  -o p3 p3.c
p3.c:14:39: warning: format specifies type 'unsigned long' but the argument has type 'int *' [-Wformat]
  printf("ip = 0x%lx.  jp = 0x%lx\n", ip, jp);
                 ~~~                  ^~
p3.c:14:43: warning: format specifies type 'unsigned long' but the argument has type 'char *' [-Wformat]
  printf("ip = 0x%lx.  jp = 0x%lx\n", ip, jp);
                              ~~~         ^~
                              %s
2 warnings generated.
UNIX> <font color=darkred><b></b></font>
</pre>

What's going on is that the compiler parses the format string of <b>printf()</b> and gleans that
"%lx" desires a <b>long unsigned int</b>, but it's getting an <b>(int *)</b>.  You go ahead
and perform a type cast on the argument to tell the compiler "Yes, this is an <b>(int *)</b>, 
but treat it like a <b>(long unsigned int)</b>, please.  I know what I'm doing."  That's in 
<b><a href=p5.c>p5.c</a></b>:

<p><center><table border=3 cellpadding=3><td><pre>
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

int main()
{
  int i;
  char j[14];
  int *ip;
  char *jp;

  ip = &i;
  jp = j;

  printf("ip = 0x%lx.  jp = 0x%lx\n", (long unsigned int) ip, (long unsigned int) jp);
  exit(0);
}
</pre></td></table></center><p>

The compiler, happy that you have taken responsibility for using mixmatched types,
compiles it without any warnings:

<pre>
UNIX> <font color=darkred><b>make p5</b></font>
gcc  -o p5 p5.c
UNIX> <font color=darkred><b>./p5</b></font>
ip = 0x7fff6ad53dfc.  jp = 0x7fff6ad53e00
UNIX> <font color=darkred><b></b></font>
</pre>

(As an aside, some compilers won't print out those warnings.  For example, on my 
Pi, there is no warning on <b>p3.c</b>.  So it goes.)
<p>
On some machines (not ours), both pointers and <b>int</b>s
are 4 bytes.  This has led many people to treat pointers and <b>int</b>s as
interchangable.  For example, look at the code in 
<b><a href=p8.c>p8.c</a></b>

<p><center><table border=3 cellpadding=3><td><pre>
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;

typedef long unsigned int LUI;

int main()
{
  char s[4];
  int i;
  char *s2;

  <font color=blue>/* Copy the string "Jim" to s, then turn the pointer into an integer i.
     Print out the pointer's value, and i's value. */</font>

  strcpy(s, "Jim"); 
  i = (int) s;
  printf("i = %d (0x%x)\n", i, i);
  printf("s = %ld (0x%lx)\n", (LUI) s, (LUI) s);

  <font color=blue>/* Now increment i, and turn it back into a pointer.  
     Print out the pointers, and then attempt to print out what they point to. */</font>

  i++;
  s2 = (char *) i;
  printf("s = 0x%lx.  s2 = 0x%lx, i = 0x%x\n", (LUI) s, (LUI) s2, i);
  printf("s[0] = %c, s[1] = %c, *s2 = %c\n", s[0], s[1], *s2);
  exit(0);
}
</pre></td></table></center><p>

When you set <b>i</b> equal to <b>s</b>, you are losing 4 bytes of information,
because <b>ints</b> are four bytes, and pointers are eight.  When you set <b>s2</b>
back to <i>i</i>, it fills in the four bytes that <b>i</b> is missing, typically with zeros,
but sometimes with -1's.  In either case, it
will be an illegal address, and you will get a segmentation violation:

<pre>
UNIX> <font color=darkred><b>./p8</b></font>
i = -206846176 (0xf3abc720)
s = 140737281509152 (0x7ffff3abc720)
s = 0x7ffff3abc720.  s2 = 0xfffffffff3abc721, i = 0xf3abc721
Segmentation fault
UNIX> <font color=darkred><b></b></font>
</pre>

Why does <b>s2</b> have all of those f's?  Because the sign bit of <i>i</i> is
negative.  Thus, when we set <b>s2</b> to <b>i</b>, it fills in the missing four
bytes with ones, making <b>s2</b> negative.
<p>
The compilers on our lab machines are happy to warn you about your potential problems,
as evidenced by the warnings here:

<pre>
UNIX> <font color=darkred><b>make p8</b></font>
gcc  -o p8 p8.c
p8.c: In function 'main':
p8.c:12: warning: cast from pointer to integer of different size
p8.c:17: warning: cast to pointer from integer of different size
UNIX> <font color=darkred><b></b></font>
</pre>

On a machine with 32-bit pointers, this code will work fine, because now integers and
pointers are the same size.  The compiler will not complain either:

<pre>
UNIX> <font color=darkred><b>gcc -m32 -o p8-32 p8.c</b></font>
UNIX> <font color=darkred><b>p8-32</b></font>
i = -4643812 (0xffb9241c)
s = -4643812 (0xffb9241c)
s = 0xffb9241c.  s2 = 0xffb9241d, i = 0xffb9241d
s[0] = J, s[1] = i, *s2 = i
UNIX> <font color=darkred><b></b></font>
</pre>

Same thing on my Pi:

<pre>
pi@raspberrypi:~/CS360/cs360-lecture-notes/CStuff$ <font color=darkred><b>make p8</b></font>
gcc -o p8 p8.c
pi@raspberrypi:~/CS360/cs360-lecture-notes/CStuff$ <font color=darkred><b>./p8</b></font>
i = 2126570764 (0x7ec0e50c)
s = 2126570764 (0x7ec0e50c)
s = 0x7ec0e50c.  s2 = 0x7ec0e50d, i = 0x7ec0e50d
s[0] = J, s[1] = i, *s2 = i
pi@raspberrypi:~/CS360/cs360-lecture-notes/CStuff$ 
</pre>

If we instead use a <b>long</b> for <b>i</b> instead of an <b>int</b>, everything works fine,
since <b>long</b>s and pointers are guaranteed to be the same size, be that 4 or 8 bytes.
The program 
<b><a href=p9.c>p9.c</a></b>
makes the requisite changes:

<p><center><table border=3 cellpadding=3><td><pre>
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;

typedef long unsigned int LUI;

int main()
{
  char s[4];
  long i;
  char *s2;

  <font color=blue>/* This is the same as p8.c, but we've changed i to a long. */</font>

  strcpy(s, "Jim"); 
  i = (long) s;
  printf("i = %ld (0x%lx)\n", i, i);
  printf("s = %ld (0x%lx)\n", (LUI) s, (LUI) s);

  i++;
  s2 = (char *) i;
  printf("s = 0x%lx.  s2 = 0x%lx, i = 0x%lx\n", (LUI) s, (LUI) s2, i);
  printf("s[0] = %c, s[1] = %c, *s2 = %c\n", s[0], s[1], *s2);
  exit(0);
}
</pre></td></table></center><p>
<pre>
UNIX> <font color=darkred><b>make p9</b></font>
gcc  -o p9 p9.c
UNIX> <font color=darkred><b>./p9</b></font>
i = 140733481930528 (0x7fff1132cf20)
s = 140733481930528 (0x7fff1132cf20)
s = 0x7fff1132cf20.  s2 = 0x7fff1132cf21, i = 0x7fff1132cf21
s[0] = J, s[1] = i, *s2 = i
UNIX> <font color=darkred><b></b></font>
</pre>

Compilers and machines all differ.  Some machines (like my old macintosh) have 32-bit
pointers and rather laconic compilers that don't give you many warnings.  Others,
like our lab machines, have 64-bit pointers and downright chatty compilers.
My philosophy is to try to program so that none of them have warnings.  That can be
a challenge, but you should strive to do the same.

<hr>
<h2>Malloc and Free</h2>

There is no <b>new</b> or <b>delete</b> in C.  Their functionality is taken by the 
library calls <b>malloc()</b> and <b>free()</b>.  Read their man pages to see their prototypes 
and include statements.  This one is from my Linux box in 2015:

<pre>
<b>SYNOPSIS</b>

       #include <stdlib.h>

       void *malloc(size_t size);
       void free(void *ptr);
</pre>

Like <b>new</b>, <b>malloc()</b> allocates bytes of memory from the operating system.
Unlike <b>new</b>, which requires you to give it information about the data type that it is
allocating, <b>malloc()</b> simply asks for the number of bytes, and if it is successful,
it will return a pointer to at least that many bytes, allocated for you by the operating
system.  It returns a <b>void *</b>, which means it's a pointer, but <b>malloc()</b> doesn't
know what it's pointing to.  Fortunately, you do know what it's pointing to, and that is what
you set its return value to.
<p>
To figure out how many bytes you need from <b>malloc()</b>, you call <b>sizeof(type)</b>.
For example, to allocate one integer, you would call <b>malloc(sizeof(int))</b>.
Often you want to allocate an array of a data type.  To do that, you multiply <b>sizeof(type)</b> 
by the number of elements.  Your pointer will point to the first of these elements.  
The next element will be <b>sizeof(type)</b> bytes after the pointer.  And so on.  We'll 
explore this more soon.
<p>
For now, take a look at
<b><a href=pm.c>pm.c</a></b>

<p><center><table border=3 cellpadding=3><td><pre>
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

<font color=blue>/* This allocates n integers, error checks and returns a pointer to them. */</font>

int *give_me_some_ints(int n)
{
  int *p;
  int i;

  p = (int *) malloc(sizeof(int) * n);
  if (p == NULL) { fprintf(stderr, "malloc(%d) failed.\n", n); exit(1); }
  return p;
}

<font color=blue>/* This takes a pointer to n integers and assigns them to random numbers. */</font>

void fill_in_the_ints(int *a, int n)
{
  int i;

  for (i = 0; i &lt; n; i++) a[i] = lrand48();
}

<font color=blue>/* This reads the command line, allocates, assigns and prints n integers. */</font>

int main(int argc, char **argv)
{
  int *array;
  int size;
  int i;

  if (argc != 2) { fprintf(stderr, "usage: pm size\n"); exit(1); }
  size = atoi(argv[1]);

  array = give_me_some_ints(size);
  fill_in_the_ints(array, size);

  for (i = 0; i &lt; size; i++) printf("%4d %10d\n", i, array[i]);
  exit(0);
}
</pre></td></table></center><p>

The procedure <b>give_me_some_ints()</b> allocates an array of <b>n</b> integers and
returns a pointer to the array.  <b>fill_in_the_ints()</b> takes a pointer to the array,
plus its size, and fills it in.  Because we are passing pointers, no copies of the array
are made.  In other words, <b>fill_in_the_ints()</b> fills in the array that was created
by the <b>malloc()</b> call.  Finally, we print out the array.
<p>
Note the difference between C and C++ here:

<UL>
<LI> You have to tell <b>malloc()</b> how many bytes you want.
<LI> <b>malloc()</b> does not know how its memory is being used -- it simply allocates bytes.
<LI> You have to keep track of the array's size.  That is inconvenient compared to a vector.
<LI> There are no reference variables in C.  Parameters are always copied.  Here, it's the
    pointer that is being copied, not the data to which it is pointing.
<LI> For that reason, there is only one copy of the array in this program.
</UL>

<p>
<b>free()</b> returns the memory so that it may be reused.  It is analogous to <b>delete</b>
in C++.  You simply pass it the pointer that <b>malloc()</b> returned.  Don't pass it any
other pointer, or a pointer that has already been freed, or really ugly things can 
happen (you'll see this in detail later in the class).
<p>
Although some people disagree with this, I am of the opinion that you should only free
memory that you are going to need for reuse, or perhaps that the system may want to use for
other programs.  We'll see an example of that in the next lecture.  If you are simply allocating
memory and then exiting your program, don't bother freeing the memory.  The operating system
will reclaim it when the program exits.

<hr>
<h2>Segmentation Violations and Bus Errors</h2>

Memory can be viewed as a giant array of bytes.  However, certain parts of
this array are not accessible.  For example, typically, elements 0 to 0x1000 are 
inaccessible.  When you try to access an inaccessible element, you generate
a <i>segmentation violation</i>.  (In the old days, it would also store the contents
of memory to a file, called a <i>core dump</i>.  These days, memory is so big that
we don't generate core dumps, although we could if we had to.)
<p>
The reason element 0 is inaccessible is that it's a common
bug to forget to initialize a pointer.  When that happens, the pointer's 
value is zero, and when you try to dereference it, you'll generate a 
segmentation violation, which helps you find the bug.  
<p>
The program 
<a href=pa.c><b>pa.c</b></a>
generates a segmentation violation by trying to dereference NULL:

<p><center><table border=3 cellpadding=3><td><pre>
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

int main()
{
  char *s;

  s = NULL;

  printf("%d\n", s[0]);
  exit(0);
}
</pre></td></table></center><p>
<pre>
UNIX> <font color=darkred><b>./pa</b></font>
Segmentation fault
UNIX> <font color=darkred><b></b></font>
</pre>

On many machines.
Whenever you access a scalar type, its value in memory must be <i>aligned</i>.
What this means is that if the type is 4 bytes, its location in memory 
must start at a memory index that is a multiple of 4.  For example, if <b>i</b>
is an <b>(int *)</b>, then if <b>i</b> is not a multiple of 4, dereferencing <b>i</b> will
be an error.  This error is manifested by a <i>bus error</i>.
Unfortunately, our machines don't demonstrate this problem, so I won't 
write code for it.

<hr>
<h2>A few quick examples with scanf()</h3>

<b>Scanf()</b> is like <b>printf()</b> in that it takes a format string and some
parameters.  However, instead of writing the parameters to the terminal, it reads
from the terminal (or whatever is standard input).  
Where <b>scanf()</b> confuses
people is that there are no reference variables in C, so you have to use pointers.
If you put "%d" in the format string, then <b>scanf()</b> will read an integer.
The parameter that you have to pass is a pointer to the integer that you want
read.  The storage for the integer has to exist.  <b>Scanf()</b> will read the
integer from standard input, and will fill in the four bytes of the integer.
<p>
Here's a simple example in 
<b><a href=scanf1.c>scanf1.c</a></b>:

<p><center><table border=3 cellpadding=3><td><pre>
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

int main()
{
  int i;
  
  if (scanf("%d", &i) == 1) {
    printf("Just read i: %d (0x%x)\n", i, i);
  } else {
    printf("Scanf() failed for some reason.\n");
  }
  exit(0);
}
</pre></td></table></center><p>

I have one integer, <b>i</b>.  That's four bytes.  They are located at <i>i</i>'s
pointer: <b>&amp;i</b>.
When I call <b>scanf()</b>, I say
to read an integer from standard input, and fill in those four bytes with that
integer.  <b>Scanf()</b> returns the number of successful reads that it did.
If our read is successful, the program prints <i>i</i> in decimal and in hexadecimal.
<p>
<pre>
UNIX> <font color=darkred><b>./scanf1</b></font>
<font color=darkred><b>10</b></font>
Just read i: 10 (0xa)
UNIX> <font color=darkred><b>./scanf1</b></font>
<font color=darkred><b>Fred</b></font>
Scanf() failed for some reason.
UNIX> <font color=darkred><b>./scanf1</b></font>
<font color=darkred><b>15.999999999999</b></font>
Just read i: 15 (0xf)
UNIX> <font color=darkred><b>./scanf1</b></font>
<font color=darkred><b>-15.99999999999999</b></font>
Just read i: -15 (0xfffffff1)
UNIX> <font color=darkred><b>./scanf1</b></font>
<font color=darkred><b>&lt;CNTL-D&gt;</b></font>
Scanf() failed for some reason.
UNIX> <font color=darkred><b>echo "" | ./scanf1</b></font>
Scanf() failed for some reason.
UNIX> <font color=darkred><b>echo 15fred | ./scanf1</b></font>
Just read i: 15 (0xf)
UNIX>
</pre>

Let's go over these examples.
<UL>
<LI> The first successfully reads 10.
<LI> In the second,
I didn't enter a number, so the <b>scanf()</b> call made no matches.
<LI> In the third, <b>scanf()</b> stops reading when it decides that the input is no longer
an integer.  In this case, that's at the decimal point, so it successfully reads 15.
<LI> The same thing happens in the fourth case -- <b>scanf()</b> is not rounding off --
it's simply reading text until it decides that its no longer reading a number.
<LI> In the fifth case, I type <b>&lt;CNTL-D&gt;</b>, which ends standard input.
<b>scanf()</b> in this case returns <b>EOF</b> (defined in <b>stdio.h</b>).  It is
a negative number, so our program prints that <b>scanf()</b> failed.
<LI> In the sixth case, I use the program <b>echo</b> to provide standard input.
In this case, <b>echo</b> produces a blank line, so <b>scanf()</b> returns <b>EOF</b> again.
<LI> Finally, the last case uses <b>echo</b> again to show that <b>scanf()</b> will successfully
read the 15.
</UL>

<p>
The program <b><a href=scanf2.c>scanf2.c</a></b> is buggy.

<p><center><table border=3 cellpadding=3><td><pre>
int main()
{
  int *i;

  printf("i = 0x%lx\n", (unsigned long) i);
  if (scanf("%d", i) == 1) {
    printf("Just read i: %d (0x%x)\n", *i, *i);
  } else {
    printf("Scanf() failed for some reason.\n");
  }
  exit(0);
}
</pre></td></table></center><p>

It will compile (although some nosy compilers will figure out it's buggy and yell at you).
Whether the bug manifests or not is a matter of luck.  

Here's the program on my Mac in 2015:

<pre>
UNIX> <font color=darkred><b>echo 10 | ./scanf2</b></font>
i = 0x7fff5fc01052
Bus error
UNIX>
</pre>

What happened?  The answer is that <i>i</i> is an uninitialized variable.  It randomly
started with a value of 0x7fff5fc01052.  When <b>scanf()</b> tried to stuff the value 10 into
those four bytes, a hardware error was generated -- that's the bus error.  If you're
lucky, when your program has uninitialized variables, they lead to segmentation
violations and bus errors.  If you're unlucky, they won't, and you don't discover
your bug until (potentially much) later.
<p>
Just to test on some other machines, 
here is is on my Raspberry Pi in 2017:
<pre>
@raspberrypi:~/CS360/cs360-lecture-notes/CStuff$ <font color=darkred><b>echo 10 | ./scanf2</b></font>
i = 0x0
Segmentation fault
pi@raspberrypi:~/CS360/cs360-lecture-notes/CStuff$ 
</pre>

The fact that <i>i</i> was zero is good here -- the 
segmentation violation clues us into the fact that there is a bug.
<p>
In 2018, my Mac gave me the disaster output:

<pre>
UNIX> <font color=darkred><b>echo 10 | ./scanf2</b></font>
i = 0x7fff57c662a0
Just read i: 10 (0xa)
UNIX> <font color=darkred><b></b></font>
</pre>

The variable  <i>i</i> just happens to be a legal and aligned address.  The value 10 has
been stuffed into bytes 0x7fff57c662a0 to 0x7fff57c662a3.  Who knows what that is in my
program.  The fact that my program simply exits means that this bug is benign, but if I 
were to have lots more going on in my program, this bug would be extremely difficult to 
figure out.  The reason is that when the error manifests, it will be much later in the program,
when some other part of the program is using addresses 0x7fff57c662a0 to 0x7fff57c662a3.  
This is why it pays to be careful when you are programming.

<P>
<h3>Strings and scanf</h3>

A string in C is an array of <b>char</b>'s.  Recall, a char is a one-byte integer,
which means that it has values between -128 and 127.  Each of those values matches
to a printable character, with zero equalling the "null" character.
A string is an array of char's that ends with the null character.  The following
program
(<b><a href=scanf3.c>scanf3.c</a></b>)
uses <b>scanf()</b> to read a string from standard input, and then to print
the individual characters:

<p><center><table border=3 cellpadding=3><td><pre>
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

int main()
{
  char s[10];
  int i;

  if (scanf("%s", s) != 1) exit(0);

  for (i = 0; s[i] != '\0'; i++) {
    printf("Character: %d: %3d %c\n", i, s[i], s[i]);
  }
  exit(0);
}
</pre></td></table></center><p>

Since an array variable like <b>s</b> is equivalent to a pointer
to the first element, we do not have to pass <b>&amp;s</b>
to <b>scanf()</b> -- we simply pass <b>s</b>.
<p>
This program allows us to see the ASCII character codes for the characters
in the string "Jim-Plank":

<pre>
UNIX> <font color=darkred><b>echo "Jim-Plank" | scanf3</b></font>
Character: 0:  74 J
Character: 1: 105 i
Character: 2: 109 m
Character: 3:  45 -
Character: 4:  80 P
Character: 5: 108 l
Character: 6:  97 a
Character: 7: 110 n
Character: 8: 107 k
UNIX> <font color=darkred><b></b></font>
</pre>

<b>scanf()</b> with strings is problematic.  Think about what happens when you enter a string
with more than 10 characters.  I will include an example in the next lecture.


<hr>
<h2>More Type Casting, Memory and Representations</h2>

With C, you can do "dangerous" things, like treat memory generically.  
In other words, suppose you have a region of bytes.  You can treat that region as if it's
holding any type you want -- integers, chars, doubles, structs, whatever.  
Typically, you don't want to leverage this flexibility, because it can get you into 
a lot of trouble.  However, when you're writing systems programs, this flexbility is
often essential.  It also helps you understand memory and what is going on with 
your machine while programs are running.
<p>
Let's take an example.  This was written by a student, Jay Pickens, while he took
CS360 in 2015:

<h3>"One little, two little, three little-endians."</h3>
By Jay Pickens (with a little editing from Dr. Plank):
<p>
This is primarily intended to be a visual aide dealing with memory, integers, little-endian format, and partial offsets.  If all you want is pics, skip to the end.
<p>
Take a look at
<b><a href=endian.c>endian.c</a></b>

<p><center><table border=3 cellpadding=3><td><pre>
#include &lt;stdio.h&gt;

typedef unsigned long UL;

int main () {

  <font color=blue>/*
    I used unsigned variables to shut up the compiler
    and to prevent preservation of negative integers when
    examining the contents of the array when viewed as
    individual bytes.
  */</font>
  unsigned int arr[4];  <font color=blue>/* An array of 4 integers */</font>
  unsigned char* bp;    <font color=blue>/* Pointer to be used to examine byte order */</font>
  unsigned int* arrp;   <font color=blue>/* Pointer to offset array */</font>

  int i;  <font color=blue>/* generic */</font>

  <font color=blue>/*
    Each byte in the array will be uniquely identified by a sequence
    two hex digits.  This was arbitrarily chosen as to ease visual
    identification of individual bytes;
  */</font>
  arr[0] = 0x00112233;
  arr[1] = 0x44556677;
  arr[2] = 0x8899AABB;
  arr[3] = 0xCCDDEEFF;

  printf( "\nINT array: 0x%08lX\n", (UL) arr );
  for ( i = 0; i &lt; 4; i++ ) {
    printf( "Index %d - Location: 0x%08lX  Size:%2d  Contents: 0x%08lX\n",
            i, (UL) (arr+i), (int) sizeof(int), (UL) arr[i] );
  }

  <font color=blue>/*
    This section sets bp equal to arr.
    We may now use bp to access the array as individual bytes.
  */</font>

  bp = (unsigned char *) arr;
  printf( "\nBYTE array: 0x%08lX\n", (UL) bp );
  for ( i = 0; i &lt; 16; i++ ) {
    printf( "Index %2d - Location: 0x%08lX  Contents: 0x%02X\n", i, (UL) (bp+i), bp[i] );
  }
  printf( "\n\n" );

  <font color=blue>/*
    Here we first increment the character pointer by one.
  */</font>
  arrp = (unsigned int *) ( bp + 1 );
  printf( "Original array begin: 0x%08lX\n", (UL) arr );
  printf( "Offset array begin:   0x%08lX\n", (UL) arrp );
  printf( "Byte offset:          %ld\n", ((UL)arrp)-((UL)arr) );
  for ( i = 0; i &lt; 4; i++ ) {
    printf( "Index %d - Location: 0x%08lX  Size:%2d  Contents: 0x%08lX\n",
            i, (UL) (arrp+i), (int) sizeof(int), (UL) arrp[i] );
  }
  printf( "\n" );

  return 0;
}
</pre></td></table></center><p>

What this code does is declare an array of four integers, which will be a total of 16 bytes of memory.
I then assigned a unique identifier to each of them, so they may be easily visually distinguished.
<p> 
Once the bytes are tagged, I then iterate over the array, displaying the memory location and contents of each.
This part is basic enough.
<p> 
Next, I use the <i>char*</i> to examine each individual byte of the array, printing out its address and contents.
I can use this to piece together the actual layout of the memory.
<p> 
Finally, I use the char* to offset another int*.  I then iterate over this "array" to see how the system can interpret
any four adjacent bytes as an integer.  I do not encounter a bus error.
<p> 
This was run on my toybox.  It is a 32-bit  pentium 4 with 786MB of RAM running Debian.

<pre>
Output:
INT array: <font color=darkblue>0xBFF33344</font>
<font color=darkred>Index</font> 0 - <font color=darkred>Location:</font> <font color=darkblue>0xBFF33344</font>  <font color=darkred>Size:</font> 4  <font color=darkred>Contents:</font> <font color=darkblue>0x00112233</font>
<font color=darkred>Index</font> 1 - <font color=darkred>Location:</font> <font color=darkblue>0xBFF33348</font>  <font color=darkred>Size:</font> 4  <font color=darkred>Contents:</font> <font color=darkblue>0x44556677</font>
<font color=darkred>Index</font> 2 - <font color=darkred>Location:</font> <font color=darkblue>0xBFF3334C</font>  <font color=darkred>Size:</font> 4  <font color=darkred>Contents:</font> <font color=darkblue>0x8899AABB</font>
<font color=darkred>Index</font> 3 - <font color=darkred>Location:</font> <font color=darkblue>0xBFF33350</font>  <font color=darkred>Size:</font> 4  <font color=darkred>Contents:</font> <font color=darkblue>0xCCDDEEFF</font>

BYTE array: <font color=darkblue>0xBFF33344</font>
<font color=darkred>Index</font>  0 - <font color=darkred>Location:</font> <font color=darkblue>0xBFF33344</font>  <font color=darkred>Contents:</font> <font color=darkblue>0x33</font>
<font color=darkred>Index</font>  1 - <font color=darkred>Location:</font> <font color=darkblue>0xBFF33345</font>  <font color=darkred>Contents:</font> <font color=darkblue>0x22</font>
<font color=darkred>Index</font>  2 - <font color=darkred>Location:</font> <font color=darkblue>0xBFF33346</font>  <font color=darkred>Contents:</font> <font color=darkblue>0x11</font>
<font color=darkred>Index</font>  3 - <font color=darkred>Location:</font> <font color=darkblue>0xBFF33347</font>  <font color=darkred>Contents:</font> <font color=darkblue>0x00</font>
<font color=darkred>Index</font>  4 - <font color=darkred>Location:</font> <font color=darkblue>0xBFF33348</font>  <font color=darkred>Contents:</font> <font color=darkblue>0x77</font>
<font color=darkred>Index</font>  5 - <font color=darkred>Location:</font> <font color=darkblue>0xBFF33349</font>  <font color=darkred>Contents:</font> <font color=darkblue>0x66</font>
<font color=darkred>Index</font>  6 - <font color=darkred>Location:</font> <font color=darkblue>0xBFF3334A</font>  <font color=darkred>Contents:</font> <font color=darkblue>0x55</font>
<font color=darkred>Index</font>  7 - <font color=darkred>Location:</font> <font color=darkblue>0xBFF3334B</font>  <font color=darkred>Contents:</font> <font color=darkblue>0x44</font>
<font color=darkred>Index</font>  8 - <font color=darkred>Location:</font> <font color=darkblue>0xBFF3334C</font>  <font color=darkred>Contents:</font> <font color=darkblue>0xBB</font>
<font color=darkred>Index</font>  9 - <font color=darkred>Location:</font> <font color=darkblue>0xBFF3334D</font>  <font color=darkred>Contents:</font> <font color=darkblue>0xAA</font>
<font color=darkred>Index</font> 10 - <font color=darkred>Location:</font> <font color=darkblue>0xBFF3334E</font>  <font color=darkred>Contents:</font> <font color=darkblue>0x99</font>
<font color=darkred>Index</font> 11 - <font color=darkred>Location:</font> <font color=darkblue>0xBFF3334F</font>  <font color=darkred>Contents:</font> <font color=darkblue>0x88</font>
<font color=darkred>Index</font> 12 - <font color=darkred>Location:</font> <font color=darkblue>0xBFF33350</font>  <font color=darkred>Contents:</font> <font color=darkblue>0xFF</font>
<font color=darkred>Index</font> 13 - <font color=darkred>Location:</font> <font color=darkblue>0xBFF33351</font>  <font color=darkred>Contents:</font> <font color=darkblue>0xEE</font>
<font color=darkred>Index</font> 14 - <font color=darkred>Location:</font> <font color=darkblue>0xBFF33352</font>  <font color=darkred>Contents:</font> <font color=darkblue>0xDD</font>
<font color=darkred>Index</font> 15 - <font color=darkred>Location:</font> <font color=darkblue>0xBFF33353</font>  <font color=darkred>Contents:</font> <font color=darkblue>0xCC</font>


Original array begin: <font color=darkblue>0xBFF33344</font>
Offset array begin:   <font color=darkblue>0xBFF33345</font>
Byte offset:          1
<font color=darkred>Index</font> 0 - <font color=darkred>Location:</font> <font color=darkblue>0xBFF33345</font>  <font color=darkred>Size:</font> 4  <font color=darkred>Contents:</font> <font color=darkblue>0x77001122</font>
<font color=darkred>Index</font> 1 - <font color=darkred>Location:</font> <font color=darkblue>0xBFF33349</font>  <font color=darkred>Size:</font> 4  <font color=darkred>Contents:</font> <font color=darkblue>0xBB445566</font>
<font color=darkred>Index</font> 2 - <font color=darkred>Location:</font> <font color=darkblue>0xBFF3334D</font>  <font color=darkred>Size:</font> 4  <font color=darkred>Contents:</font> <font color=darkblue>0xFF8899AA</font>
<font color=darkred>Index</font> 3 - <font color=darkred>Location:</font> <font color=darkblue>0xBFF33351</font>  <font color=darkred>Size:</font> 4  <font color=darkred>Contents:</font> <font color=darkblue>0x45CCDDEE</font>
</pre>
Analyzing this output I can draw the following diagram:
<p><center><table border=3><td><a href=endian.jpg><img src=endian.jpg width=800></a></td></table></center><p>

Each column represents an 8-bit cell in the memory.  The actual memory address of each cell is in the top column, and multiple of 4 are in bold.
Note:  The gray areas my not be system memory, but it is not memory that has been declared.
<p> 
First of note would be the middle column, in blue.  This is the array of bytes as it was initially declared and set.
<p> 
Second, we have in green the actual bytes as they lay in memory.  This is a little endian system.
<p> 
Finally, in yellow we have our 1-Byte offset array.
As you can see form the output, I neither got a seg-fault nor a bus error.  Ths single block in red is where the shifted array goes out of declared memory.
Likewise, since it does not match the tag of any declared byte, we have no idea where it came form or why it contains 0x45."
<p>
End quote -- thanks, Jay!
<hr>

<h2>Alignment within structs</h2>
<p>
<b>Malloc()</b> always returns pointers that are multiples of 8
-- therefore using <b>malloc()</b> to allocate any scalar type or
array of scalar types will generate pointers that are correctly
aligned.  
<p>
Moreover, the compiler always lays out structs so that the fields are
aligned.  Thus, in the following struct:
<pre>
struct {
  char b;
  int i;
}
</pre>
The whole struct will be 8 bytes -- 1 for <b>b</b>, 3 unused, and 4 for <b>i</b>.
The 3 bytes are necessary so that <b>i</b> will be aligned.  The compiler
does not shuffle around the fields so that they pack into memory better.
So, for example, if you have:
<pre>
struct {
  char b1;
  int i1;
  char b2;
  int i2;
}
</pre>
The struct will be 16 bytes:
<UL>
<li> 1 for <b>b1</b>
<li> 3 unused
<li> 4 for <b>i1</b>
<li> 1 for <b>b2</b>
<li> 3 unused
<li> 4 for <b>i2</b>
</UL>
<p>
However, if you order them differently, you can get all of those fields into
12 bytes:
<pre>
struct {
  char b1;
  char b2;
  int i1;
  int i2;
}
</pre>
Now the struct will have:
<UL>
<li> 1 byte for <b>b1</b>
<li> 1 byte for <b>b2</b>
<li> 2 unused bytes
<li> 4 bytes for <b>i1</b>
<li> 4 bytes for <b>i2</b>
</UL>

Finally, the following struct's size is also 8 bytes, even though you may initially think it
should only be five:

<pre>
typedef struct {
  int i;
  char b;
} S1B;
</pre>

Why?  Because if you wanted to allocate an array of ten of these using <b>malloc()</b>, you'd
do the following:

<p><center><table border=3 cellpadding=3><td><pre>
S1B *s;

s = (S1B *) malloc(sizeof(S1B)*10);
</pre></td></table></center><p>

Now, suppose <b>sizeof(S1B)</b> is only 5.  We know that <b>s</b> will be a multiple of 8
because <b>malloc()</b> guarantees that.  What about <b>&amp;(s[1])</b>?  That will be five
bytes greater than <b>s</b>, which means it won't be a multiple of 8 -- of a multiple of 4.
It is unaligned, and importantly <b>s[1].i</b> is unaligned.  By making <b>sizeof(S1B)</b>
be 8, we have no alignment problems when we use the type in an array.
<p>

The program 
<b><a href=pd.c>pd.c</a></b>
confirms all of these assertions:

<pre>
UNIX> <font color=darkred><b>pd</b></font>
8 16 12 8
UNIX> <font color=darkred><b></b></font>
</pre>


<hr>
<h2>A Common Type Bug</h2>

This looks idiotic, but it is at the heart of most type bugs.
Look at <a href=pc.c><c>pc.c</c></a>:

<b><a href=pc.c>pc.c</a></b>

<p><center><table border=3 cellpadding=3><td><pre>
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

int main()
{
  char c;
  int i;
  int j;

  i = 10000;
  c = i;             <font color=blue>/* You are losing information here. */</font>
  j = c;

  printf("I: %d,   J: %d,       C: %d\n", i, j, c);
  printf("I: 0x%04x,  J: 0x%04x,   C: 0x%04x\n", i, j, c);
  exit(0);
}
</pre></td></table></center><p>

Since <b>c</b> is a <b>char</b>, it cannot hold the value 10000.  It will
instead hold the lowest order byte of <b>i</b>, which is 16 (0x10).  Then
when you set <b>j</b> to <b>c</b>, you'll see that <b>j</b> becomes 16.
<p>
Also, even our chatty compiler doesn't complain about it.   Make sure
you understand this bug and the output below:

<pre>
UNIX> <font color=darkred><b>make pc</b></font>
gcc -g -c pc.c
gcc -g -o pc pc.o
UNIX> <font color=darkred><b>pc</b></font>
I: 10000,   J: 16,       C: 16
I: 0x2710,  J: 0x0010,   C: 0x0010
UNIX> <font color=darkred><b></b></font>
</pre>

