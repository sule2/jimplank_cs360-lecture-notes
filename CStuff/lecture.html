<title> Getting Started with C, Types, Pointers, Casting, Malloc, Segementation Violations and Bus Errors</title>
<body bgcolor=FFFFFF>
<h2> Getting Started with C, Types, Pointers, Casting, Malloc, Segementation Violations and Bus Errors</h2>

<UL>
<LI> <a href=http://www.cs.utk.edu/~plank>James S. Plank</a>
<LI> <a href=http://www.cs.utk.edu/~plank/plank/classes/cs360/>CS360</a>
<LI> Url: <a href=http://www.cs.utk.edu/~plank/plank/classes/cs360/360/notes/CStuff/lecture.html><b>
                  http://www.cs.utk.edu/~plank/plank/classes/cs360/360/notes/CStuff/lecture.html</b></a>
<LI> Programs are on the UT lab machines at <b>~plank/cs360/notes/CStuff</b>
<LI> And bitbucket: <a href=https://bitbucket.org/jimplank/cs360-lecture-notes>https://bitbucket.org/jimplank/cs360-lecture-notes</a>.
<LI> Originally written in 1995.
<LI> Last modification: <i>
Tue Jan  9 16:58:07 EST 2018
</i>
</UL>

<h1>Moving from C++ to C</h1>

This class is taught in C, rather than C++.  The reasoning is as follows:
Because C hides so much
less from you than C++, you have a much easier time figuring out what's 
going on when you run one or more programs.  This will be a little painful,
because you lose so many of the wonderful things about C++ on which you have
grown to rely, like <b>cin</b>, strings, objects with methods, and the standard
template library.  Sorry.  
<p>
These lecture notes detail the parts of C++ that you lose when you migrate
to C, and how you replace them.
<p>
You have to use <b>gcc</b> to compile programs in this class.  You <i>cannot</i>
use <b>g++</b>.  Don't give the TA's C++ code and say you didn't know.  You know.
<p>
Time to learn C.
<hr>
<h2>Header files</h2>
As with C++, you include standard header files with <b>#include</b>.  You include
the file name in less-than/greater-than signs, and you include the <b>.h</b> extension.
Instead of starting your programs with:
<p><center><table border=3 cellpadding=3><td><pre>
#include &lt;iostream&gt;
using namespace std;
</pre></td></table></center><p>
you start them with:
<p><center><table border=3 cellpadding=3><td><pre>
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
</pre></td></table></center><p>
I never liked that "using namespace std" stuff anyway.
<hr>
<h2>Comments</h2>

Comments in C are delimited by "/*" and "*/".  The former starts the comment, which 
can span multiple lines, and the latter ends the comment.   (C++ style commenting 
has been added to the C standard, so you can use it, but I don't -- you never know when
you're going to be running on that 1979 VM....)
<hr>

<h2>Bye-bye, cin and cout</h2>

Frankly, this isn't too painful, and will be less so when you learn the fields library.
I'm assuming that you already know <b>printf()</b> from previous classes.  
That handles output.  
For input, we'll focus on three procedures that are defined
in <b>stdio.h</b>: <b>scanf()</b>, <b>fscanf()</b> and <b>fgets()</b>.
We'll get to them a little later in the lecture.  
Chances are that you know <b>sscanf()</b> already.  If you don't, you'll learn it.  




<hr>
<h2>TYPES in C</h2>

In C, there are three kinds of types that variables can have -- scalars, 
      aggregates, and pointers.  Half of the game in getting things right
      in C is keeping yourself from being confused about types.  This lecture
      tries to elaborate on this a little.

<h2>Scalar Types</h2>

There are 7 scalar types in C:

<LI> <b>char</b>       -- 1 byte
<LI> <b>short</b>      -- 2 bytes
<LI> <b>int</b>        -- 4 bytes
<LI> <b>long</b>       -- 4 or 8 bytes, depending on the system and compiler
<LI> <b>float</b>      -- 4 bytes
<LI> <b>double</b>     -- 8 bytes
<LI> (pointer    -- 4 or 8 bytes, depending on the system and compiler)
<p>
These should all be familiar to you (ok, maybe not a <b>short</b>, but the rest should).  
If you want to verify or use the size of a type in C, you use the macro <b>sizeof()</b>.
For example, <b>sizeof(long)</b> will return either 4 or 8, depending on how big a <b>long</b>
is in your system.
<p>
You can declare a scalar variable in 
one of three places:  As a global variable, as a procedure parameter, and 
as a local variable.  For example, look at the program below in 
<a href=p1.c><b>p1.c</b></a>:
<p>
(In this and all other lecture notes, you can copy the programs and the
makefile into your own directory, and then compile them by using <b>make</b>.
E.g. to make the program <b>p1</b>, you say ``<b>make p1</b>'').
<p>
<p><center><table border=3 cellpadding=3><td><pre>
#include &lt;stdio.h&gt;

int i;

main(int argc, char **argv)
{
  int j;

  j = argc;
  i = j;
  printf("%d\n", i);
}
</pre></td></table></center><p>
There are three scalar int variables here -- <b>i</b>, <b>j</b>, and 
<b>argc</b>.  <b>I</b> is a global 
variable.  <b>J</b> is a local variable, and <b>argc</b> 
is a parameter.  Scalars are 
pretty straightforward.   You can pass them as parameters to procedures, and 
return them from procedures without worrying about anything going awry.  

<hr>
<h2>Aggregate Types</h2>

Arrays and structs are aggregate types in C.  They are more complex than 
scalars.  You can statically declare an array as a global or local variable --
I do both below in 
<b><a href=p2.c>p2.c</a></b>:

<p><center><table border=3 cellpadding=3><td><pre>
#include &lt;stdio.h&gt;

char s1[15];

main(int argc, char **argv)
{
  char s2[4];

...
</pre></td></table></center><p>
<b>S1</b> is a global array of 15 chars and 
<b>s2</b> is a local array of 4 chars.  
<p>
If an array has been statically declared, then you cannot assign it to 
another array.  For example, look at <a href=p2.c><b>p2.c</b></a>:

<p><center><table border=3 cellpadding=3><td><pre>
#include &lt;stdio.h&gt;

char s1[15];

main(int argc, char **argv)
{
  char s2[4];
  
  s2 = "Jim";
}
</pre></td></table></center><p>
The statement ``<b>s2 = "Jim"</b>'' is illegal in C, because <b>s2</b> has 
been statically 
declared.  If you try to compile this program, <b>gcc</b> 
will give you an error:
<pre>
UNIX> <font color=darkred><b>gcc -o p2 p2.c</b></font>
p2.c: In function `main':
p2.c:10: incompatible types in assignment
UNIX>
</pre>
This is a good rule to bear in mind -- if <b>x</b> 
is an array, then you should <i>NEVER</i> say 
``<b>x = <i>something</i></b>''.  It
will usually give you an error.  However, if it doesn't (because they change
the compiler yet again), you are writing bad C code.
<p>
However, you can always say ``<b><i>something</i> = x</b>''.  We'll discuss later in the 
lecture.
<p>
<hr>
<h3>Structs</h3>

The second way to aggregate data is with a <b>struct</b>.  A <b>struct</b> looks a little
like a C++ class with some notable omissions:
<UL>
<LI> No "public/protected/private" mess.
<LI> No constructors/destructors.
<LI> No default "copy" methods or any of that mess.
<LI> No methods.
</UL>

Suppose we want to aggregate an int and a double.  We can do that as in 
<b><a href=id1.c>id1.c</a></b>

<p><center><table border=3 cellpadding=3><td><pre>
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

struct intdouble {
  int i;
  double d;
};

main()
{
  struct intdouble id1;

  id1.i = 5;
  id1.d = 3.14;

  printf("%d %.2lf\n", id1.i, id1.d);
}
</pre></td></table></center><p>

<pre>
UNIX> <font color=darkred><b>id1</b></font>
5 3.14
UNIX> <font color=darkred><b></b></font>
</pre>

You can use a <b>typedef</b> to make it a little more readable (<b><a href=id2.c>id2.c</a></b>):

<p><center><table border=3 cellpadding=3><td><pre>
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

typedef struct intdouble {
  int i;
  double d;
} ID;

main()
{
  ID id1;

  id1.i = 5;
  id1.d = 3.14;

  printf("1: %d %.2lf\n", id1.i, id1.d);
}
</pre></td></table></center><p>

You may have some confusion with structs, because they exist in C++ with different
semantics.  Let's take a look at the following code in C++, which declares two
<b>intdouble</b>'s, sets one's variables, and then copies one to the other (<b><a href=id3.cpp>id3.cpp</a></b>):

<p><center><table border=3 cellpadding=3><td><pre>
#include &lt;cstdio&gt;
#include &lt;iostream&gt;
using namespace std;

struct intdouble {
  int i;
  double d;
};

main()
{
  intdouble id1, id2;

  id1.i = 5;
  id1.d = 3.14;

  id2 = id1;
  id2.i += 5;
  id2.d += 5;

  printf("1: %d %.2lf\n", id1.i, id1.d);
  printf("2: %d %.2lf\n", id2.i, id2.d);
}
</pre></td></table></center><p>

Straightforward when it runs:

<pre>
UNIX> <font color=darkred><b>id3</b></font>
1: 5 3.14
2: 10 8.14
UNIX> <font color=darkred><b></b></font>
</pre>


Let's change this to C.  If we simply fix the headers, this will not compile.
That is because C++ creates 
"intdouble" as a type, and C does not.  When we try to compile, it fails:

<pre>
UNIX> <font color=darkred><b>gcc -o id4 id4.c</b></font>
id4.c: In function 'main':
id4.c:11: error: 'intdouble' undeclared (first use in this function)
id4.c:11: error: (Each undeclared identifier is reported only once
id4.c:11: error: for each function it appears in.)
id4.c:11: error: expected ';' before 'id1'
id4.c:13: error: 'id1' undeclared (first use in this function)
id4.c:16: error: 'id2' undeclared (first use in this function)
UNIX> <font color=darkred><b></b></font>
</pre>

Now, if you put "struct" in front of "intdouble," that will fix the 
problem.  It is in
<b><a href=id5.c>id5.c</a></b>:

<p><center><table border=3 cellpadding=3><td><pre>
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

struct intdouble {
  int i;
  double d;
};

main()
{
  struct intdouble id1, id2;

  id1.i = 5;
  id1.d = 3.14;

  id2 = id1;

  id2.i += 5;
  id2.d += 5;

  printf("1: %d %.2lf\n", id1.i, id1.d);
  printf("2: %d %.2lf\n", id2.i, id2.d);
}
</pre></td></table></center><p>

This runs identically to the C++ version.  I can tell you that I disapprove of 
this code.  Why, because the statement ``<b>id2 = id1</b>'' offends me.  It is the 
only part of C where you can copy an unspecified number of bytes with an assignment
statement.  It is a weakness of the language.  For example, take a look at
<b><a href=id5a.c>id5a.c</a></b>:

<p><center><table border=3 cellpadding=3><td><pre>
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

typedef struct {
  int a[1000];
} SID;

main()
{
  SID s1, s2;
  int i;

  for (i = 0; i &lt; 1000; i++) s1.a[i] = i;

  s2 = s1;  <b>/* THE OFFENDING LINE */</b>

  for (i = 0; i &lt; 1000; i++) printf("%4d %4d\n", s1.a[i], s2.a[i]);
 
  exit(1);
}
</pre></td></table></center><p>

The ``<b>s2 = s1</b>'' line copies 4000 bytes.  While I expect such garbage in C++,
I am surprised that it's legal in C.  Why does it allow you to copy the struct, but
not to copy the array?  Who knows -- anyway, I want you to be aware of it.
You will never see me use that feature of the language because I don't approve.

As a corollary, you can pass a struct as an argument to a procedure, and in C++
fashion, it makes a copy of the entire thing.  You'll note that in 
<b><a href=id5b.c>id5b.c</a></b>, I define a procedure <b>a()</b>, which changes the
last element of the array, and when we run it, <b>s1.a[999]</b> is unchanged.  
Make a mental note of it.

<p><center><table border=3 cellpadding=3><td><pre>
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

typedef struct {
  int a[1000];
} SID;

void a(SID s)
{
  s.a[999] = -1;
}


main()
{
  SID s1, s2;
  int i;

  for (i = 0; i &lt; 1000; i++) s1.a[i] = i;
  s2 = s1;

  a(s1);
  for (i = 0; i &lt; 1000; i++) printf("%4d %4d\n", s1.a[i], s2.a[i]);
 
  exit(1);
}
</pre></td></table></center><p>

<pre>
UNIX> <font color=darkred><b>id5b | tail</b></font>
 990  990
 991  991
 992  992
 993  993
 994  994
 995  995
 996  996
 997  997
 998  998
 999  999
UNIX> <font color=darkred><b></b></font>
</pre>

<p>
A final note about C++ structs.  They are basically stripped down classes -- you 
can put methods in them, and then implement the methods using the struct's variables,
as in <b><a href=id6.cpp>id6.cpp</a></b>:

<p><center><table border=3 cellpadding=3><td><pre>
#include &lt;cstdio&gt;
#include &lt;iostream&gt;
using namespace std;

struct intdouble {
  int i;
  double d;
  void Print();
};

void intdouble::Print()
{
  printf("   %d %.2lf\n", i, d);
}
  
main()
{
  intdouble id1, id2;

  id1.i = 5;
  id1.d = 3.14;

  id2 = id1;
  id2.i += 5;
  id2.d += 5;

  id1.Print();
  id2.Print();
}
</pre></td></table></center><p>

Whoever designed structs in C++ did the world a disservice, because you have the same
constructs in two fairly similar languages that have completely different semantics.
Which means that tons of people are going to be confused going from C++ to C, or 
even C to C++ when their struct semantics are off.  It is for this reason that
I don't teach structs as a C++ construct in either CS140 or CS302.  Just use
a class.

<hr>
<h2>Pointers</h2>

Pointers are where most people mess up in C.  A pointer is simply a
pointer to memory.  Memory can be allocated in one of two ways -- by
declaring variables, or by calling <b>malloc()</b> (there is no <b>new</b> in C).  
Whenever memory has been
allocated, you can set a pointer to it.
<p>
You can view memory as one huge array of bytes (chars).  This array has
2<sup>32</sup> or 2<sup>64</sup> elements.  
Usually, we consider the indices to this array in 
hexadecimal.  In other words, the array goes from <b>0x0</b> to 
<b>0xffffffff</b> (or <b>0xffffffffffffffff</b>).
<p>
A pointer is simply an index of this array.  Whenever we allocate <i>x</i> bytes
of memory, we are reserving <i>x</i> contiguous elements from the memory array.
If we set a pointer to these bytes, then that pointer will be the index
of the first allocated byte in memory.
<p>
For example, look at the following program (in 
<a href=p3.c><b>p3.c</b></a>):

<p><center><table border=3 cellpadding=3><td><pre>
main()
{
  int i;
  char j[14];
  int *ip;
  char *jp;

  ip = &i;
  jp = j;

  printf("ip = 0x%lx.  jp = 0x%lx\n", ip, jp);
}
</pre></td></table></center><p>

This program allocates one integer (<b>i</b>), an array of 14 characters 
(<b>j</b>), and
two pointers (<b>ip</b> and <b>jp</b>).  
It then sets the pointers so that they point to
the memory allocated for <b>i</b> and <b>j</b>.  Finally, 
it prints out the values of those
pointers -- these are indices into the memory array.  
<p>
Unfortunately, when we try to compile this, we get warnings.  Don't worry
about them yet -- we'll get to that.  It still compiles correctly.
<p>
When we run it, we
get:
<pre>
UNIX> <font color=darkred><b>p3</b></font>
ip = 0x7fff2efcdd9c.  jp = 0x7fff2efcdda0
UNIX> <font color=darkred><b></b></font>
</pre>
What this means is that when we view memory as an array, elements
<b>0x7fff2efcdd9c</b>, <b>0x7fff2efcdd9d</b>, <b>0x7fff2efcdd9e</b>, 
and <b>0x7fff2efcdd9f</b> are allocated for
the local variable <b>i</b>, and elements <b>0x7fff2efcdda0</b> 
through <b>0x7fff2efcddad</b>
are allocated for the array <b>j</b>.
<p>
Note that I said ``<b>jp = j</b>'' and not ``<b>jp = &j</b>''.  
This is because when 
treated as an expression, an array is equivalent to a pointer.  The only
difference is that you cannot assign a value to an array variable.  Thus,
you can say ``<b>jp = j</b>'', but you cannot say ``<b>j = jp</b>''.  
Moreover, you cannot
take the address of an array variable -- saying ``<b>&j</b>'' is illegal. 
<p>
Pointers are a little like scalars -- they too can be declared as globals, 
locals or parameters, and can be assigned values, passed as parameters, and 
returned from procedures.  On our lab machines, pointers are 8 bytes.  Thus,
in <b>p3.c</b>, there are 34 bytes of local variables allocated in the 
<b>main()</b>
procedure -- 4 for <b>i</b>, 14 for <b>j</b>, 
8 for <b>ip</b>, and 8 for <b>jp</b>.


<hr>
<h2>Type Casting (sometimes called ``type coercion'')</h2>

There are times when you would like
to take <i>x</i> bytes of memory of a certain type, and assign them to 
<i>y</i> bytes
of memory of another type.  This is called ``type casting''.  A simple
example is when you want to turn a <b>char</b> into an <b>int</b>, 
or an <b>int</b> into a <b>float</b> as in 
<a href=p4.c><b>p4.c</b></a>:

<p><center><table border=3 cellpadding=3><td><pre>
main()
{
  char c;
  int i;
  float f;

  c = 'a';
  i = c;
  f = i;
  printf("c = %d (%c).   i = %d (%c).  f = %f\n", c, c, i, i, f);
}

</pre></td></table></center><p>

The statement `<b>i = c</b>' is a type cast, as is the statement `<b>f = i</b>'.
<p>
Some type castings, like the one above, are very natural.  The C compiler 
will do these for you without complaining.  Most others, however, the C
compiler will complain about, unless you specifically tell it that you are
doing a type cast (this is a way of telling the compiler ``Yes, I know 
what I'm doing.'').  
<p>
An example is program 
<b><a href=p3.c>p3.c</a></b> above -- as mentioned, when we compile it, we
get warnings:

<pre>
UNIX> <font color=darkred><b>make p3</b></font>
gcc -g -c p3.c
p3.c: In function 'main':
p3.c:13: warning: format '%lx' expects type 'long unsigned int', but argument 2 has type 'int *'
p3.c:13: warning: format '%lx' expects type 'long unsigned int', but argument 3 has type 'char *'
gcc -g -o p3 p3.o
UNIX> <font color=darkred><b></b></font>
</pre>

What's going on is that the compiler parses the format string of <b>printf()</b> and gleans that
"%lx" desires a <b>long unsigned int</b>, but it's getting an <b>(int *)</b>.  You go ahead
and perform a type cast on the argument to tell the compiler "Yes, this is an (int *) but treat
it like a <b>(long unsigned int)</b>, please.  I know what I'm doing."  That's in 
<b><a href=p5.c>p5.c</a></b>:

<p><center><table border=3 cellpadding=3><td><pre>
#include &lt;stdio.h&gt;

main()
{
  int i;
  char j[14];
  int *ip;
  char *jp;

  ip = &i;
  jp = j;

  printf("ip = 0x%lx.  jp = 0x%lx\n", (long unsigned int) ip, (long unsigned int) jp);
}
</pre></td></table></center><p>

The compiler, happy that you have taken responsibility for using mixmatched types,
compiles it without any warnings:

<pre>
UNIX> <font color=darkred><b>make p5</b></font>
gcc -g -c p5.c
gcc -g -o p5 p5.o
UNIX> <font color=darkred><b>p5</b></font>
ip = 0x7fff6ad53dfc.  jp = 0x7fff6ad53e00
UNIX> <font color=darkred><b></b></font>
</pre>

On some machines (not ours), both pointers and <b>int</b>s
are 4 bytes.  This has led many people to treat pointers and <b>int</b>s as
interchangable.  For example, look at the code in 
<b><a href=p8.c>p8.c</a></b>

<p><center><table border=3 cellpadding=3><td><pre>
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;

main()
{
  char s[4];
  int i;
  char *s2;

  strcpy(s, "Jim");
  i = (int) s;
  printf("i = %d (0x%x)\n", i, i);
  printf("s = %ld (0x%lx)\n", (long unsigned int) s, (long unsigned int) s);

  i++;
  s2 = (char *) i;
  printf("s = 0x%lx.  s2 = 0x%lx, i = 0x%x\n", 
           (long unsigned int) s, 
           (long unsigned int) s2, i);
  printf("s[0] = %c, s[1] = %c, *s2 = %c\n", s[0], s[1], *s2);
}
</pre></td></table></center><p>

When you set <b>i</b> equal to <b>s</b>, you are losing 4 bytes of information,
because <b>ints</b> are four bytes, and pointers are eight.  When you set <b>s2</b>
back to <i>i</i>, it fills in those four bytes that <b>i</b> is missing.  Thus it
will be an illegal address, and you will get a segmentation violation:

<pre>
UNIX> <font color=darkred><b>p8</b></font>
i = -206846176 (0xf3abc720)
s = 140737281509152 (0x7ffff3abc720)
s = 0x7ffff3abc720.  s2 = 0xfffffffff3abc721, i = 0xf3abc721
Segmentation fault
UNIX> <font color=darkred><b></b></font>
</pre>

Why does <b>s2</b> have all of those f's?  Because the sign bit of <i>i</i> is
negative.  Thus, when we set <b>s2</b> to <b>i</b>, it fills in the missing four
bytes with ones, making <b>s2</b> negative.
<p>
The compilers on our lab machines are happy to warn you about your potential problems,
as evidenced by the warnings here:

<pre>
UNIX> <font color=darkred><b>make p8</b></font>
gcc -g -o p8 p8.c
p8.c: In function 'main':
p8.c:12: warning: cast from pointer to integer of different size
p8.c:17: warning: cast to pointer from integer of different size
UNIX> <font color=darkred><b></b></font>
</pre>

On a machine with 32-bit pointers, this code will work fine, because now integers and
pointers are the same size.  You can force
our machines to do that with the compilation flag "-m32", and the program
works well.  The compiler doesn't complain either:

<pre>
UNIX> <font color=darkred><b>gcc -m32 -o p8-32 p8.c</b></font>
UNIX> <font color=darkred><b>p8-32</b></font>
i = -4643812 (0xffb9241c)
s = -4643812 (0xffb9241c)
s = 0xffb9241c.  s2 = 0xffb9241d, i = 0xffb9241d
s[0] = J, s[1] = i, *s2 = i
UNIX> <font color=darkred><b></b></font>
</pre>

If we instead use a <b>long</b> for <b>i</b> instead of an <b>int</b>, everything works fine,
since <b>long</b>s and pointers are guaranteed to be the same size, be that 4 or 8 bytes.
The program 
<b><a href=p9.c>p9.c</a></b>
makes the requisite changes:

<p><center><table border=3 cellpadding=3><td><pre>
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;

main()
{
  char s[4];
  long i;
  char *s2;

  strcpy(s, "Jim");
  i = (long) s;
  printf("i = %ld (0x%lx)\n", i, i);
  printf("s = %ld (0x%lx)\n", (long unsigned int) s, (long unsigned int) s);

  i++;
  s2 = (char *) i;
  printf("s = 0x%lx.  s2 = 0x%lx, i = 0x%lx\n", 
           (long unsigned int) s, 
           (long unsigned int) s2, i);
  printf("s[0] = %c, s[1] = %c, *s2 = %c\n", s[0], s[1], *s2);
}
</pre></td></table></center><p>

<pre>
UNIX> <font color=darkred><b>make p9</b></font>
gcc -g -c p9.c
gcc -g -o p9 p9.o
UNIX> <font color=darkred><b>p9</b></font>
i = 140733481930528 (0x7fff1132cf20)
s = 140733481930528 (0x7fff1132cf20)
s = 0x7fff1132cf20.  s2 = 0x7fff1132cf21, i = 0x7fff1132cf21
s[0] = J, s[1] = i, *s2 = i
UNIX> <font color=darkred><b></b></font>
</pre>

Compilers and machines all differ.  Some machines (like my old macintosh) have 32-bit
pointers and rather laconic compilers that don't give you many warnings.  Others,
like our lab machines, have 64-bit pointers and downright chatty compilers.
Be ready for all of them.

<hr>
<h2>Malloc and Free</h2>

There is no <b>new</b> or <b>delete</b> in C.  Their functionality is taken by the 
library calls <b>malloc()</b> and <b>free()</b>.  Read their man pages to see their prototypes 
and include statements.  This one is from my Linux box in 2015:

<pre>
<b>SYNOPSIS</b>

       #include <stdlib.h>

       void *malloc(size_t size);
       void free(void *ptr);
</pre>

Like <b>new</b>, <b>malloc()</b> allocates bytes of memory from the operating system.
Unlike <b>new</b>, which requires you to give it information about the data type that it is
allocating, <b>malloc()</b> simply asks for the number of bytes, and if it is successful,
it will return a pointer to at least that many bytes, allocated for you by the operating
system.  It returns a <b>void *</b>, which means it's a pointer, but <b>malloc()</b> doesn't
know what it's pointing to.  Fortunately, you do know what it's pointing to, and that is what
you set its return value to.
<p>
To figure out how many bytes you need from <b>malloc()</b>, you call <b>sizeof(type)</b>.
For example, to allocate one integer, you would call <b>malloc(sizeof(int))</b>.
Often you want to allocate an array of a data type.  To do that, you multiply <b>sizeof(type)</b> 
by the number of elements.  Your pointer will point to the first of these elements.  
The next element will be <b>sizeof(type)</b> bytes after the pointer.  And so on.  We'll 
explore this more soon.
<p>
For now, take a look at
<b><a href=pm.c>pm.c</a></b>

<p><center><table border=3 cellpadding=3><td><pre>
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

int *give_me_some_ints(int n)
{
  int *p;
  int i;

  p = (int *) malloc(sizeof(int) * n);
  if (p == NULL) { fprintf(stderr, "malloc(%d) failed.\n", n); exit(1); }
  return p;
}

void fill_in_the_ints(int *a, int n)
{
  int i;

  for (i = 0; i &lt; n; i++) a[i] = lrand48();
}

main(int argc, char **argv)
{
  int *array;
  int size;
  int i;

  if (argc != 2) { fprintf(stderr, "usage: pm size\n"); exit(1); }
  size = atoi(argv[1]);

  array = give_me_some_ints(size);
  fill_in_the_ints(array, size);

  for (i = 0; i &lt; size; i++) printf("%4d %10d\n", i, array[i]);
  exit(0);
}
</pre></td></table></center><p>

The procedure <b>give_me_some_ints()</b> allocates an array of <b>n</b> integers and
returns a pointer to the array.  <b>fill_in_the_ints()</b> takes a pointer to the array,
plus its size, and fills it in.  Because we are passing pointers, no copies of the array
are made.  In other words, <b>fill_in_the_ints()</b> fills in the array that was created
by the <b>malloc()</b> call.  Finally, we print out the array.

<p>
<b>free()</b> returns the memory so that it may be reused.  It is analogous to <b>delete</b>
in C++.  You simply pass it the pointer that <b>malloc()</b> returned.  Don't pass it any
other pointer, or a pointer that has already been freed, or really ugly things can 
happen (you'll see this in detail later in the class).
<p>
Although some people disagree with this, I am of the opinion that you should only free
memory that you are going to need for reuse, or perhaps that the system may want to use for
other programs.  We'll see an example of that in the next lecture.  If you are simply allocating
memory and then exiting your program, don't bother freeing the memory.  The operating system
will reclaim it when the program exits.

<hr>
<h2>Segmentation Violations and Bus Errors</h2>

Memory can be viewed as a giant array of bytes.  However, certain parts of
this array are not accessible.  For example, typically, elements 0 to 0x1000 are 
inaccessible.  When you try to access an inaccessible element, you generate
a <i>segmentation violation</i>.  (In the old days, it would also store the contents
of memory to a file, called a <i>core dump</i>.  These days, memory is so big that
we don't generate core dumps, although we could if we had to.)
<p>
The reason element 0 is inaccessible is that it's a common
bug to forget to initialize a pointer.  When that happens, the pointer's 
value is zero, and when you try to dereference it, you'll generate a 
segmentation violation, which helps you find the bug.  
<p>
The program 
<a href=pa.c><b>pa.c</b></a>
generates a segmentation violation by trying to dereference NULL:

<p><center><table border=3 cellpadding=3><td><pre>
#include &lt;stdio.h&gt;

main()
{
  char *s;

  s = NULL;

  printf("%d\n", s[0]);
}
</pre></td></table></center><p>

<pre>
UNIX> <font color=darkred><b>pa</b></font>
Segmentation fault
UNIX> <font color=darkred><b></b></font>
</pre>

On many machines.
Whenever you access a scalar type, its value in memory must be <i>aligned</i>.
What this means is that if the type is 4 bytes, its location in memory 
must start at a memory index that is a multiple of 4.  For example, if <b>i</b>
is an <b>(int *)</b>, then if <b>i</b> is not a multiple of 4, dereferencing <b>i</b> will
be an error.  This error is manifested by a <i>bus error</i>.
Unfortunately, our machines don't demonstrate this problem, so I won't 
write code for it.

<hr>
<h2>More Type Casting, Memory and Representations</h2>

With C, you can do "dangerous" things, like treat memory generically.  
In other words, suppose you have a region of bytes.  You can treat that region as if it's
holding any type you want -- integers, chars, doubles, structs, whatever.  
Typically, you don't want to leverage this flexibility, because it can get you into 
a lot of trouble.  However, when you're writing systems programs, this flexbility is
often essential.  It also helps you understand memory and what is going on with 
your machine while programs are running.
<p>
Let's take an example.  This was written by a student, Jay Pickens, while he took
CS360 in 2015:

<h3>"One little, two little, three little-endians."</h3>
By Jay Pickens (with a little editing from Dr. Plank):
<p>
This is primarily intended to be a visual aide dealing with memory, integers, little-endian format, and partial offsets.  If all you want is pics, skip to the end.
<p>
Take a look at
<b><a href=endian.c>endian.c</a></b>

<p><center><table border=3 cellpadding=3><td><pre>
#include &lt;stdio.h&gt;

typedef unsigned long UL;

int main () {

  /*
    I used unsigned variables to shut up the compiler
    and to prevent preservation of negative integers when
    examining the contents of the array when viewed as
    individual bytes.
  */
  unsigned int arr[4];  /* An array of 4 integers */
  unsigned char* bp;    /* Pointer to be used to examine byte order */
  unsigned int* arrp;   /* Pointer to offset array */

  int i;  /* generic */

  /*
    Each byte in the array will be uniquely identified by a sequence
    two hex digits.  This was arbitrarily chosen as to ease visual
    identification of individual bytes;
  */
  arr[0] = 0x00112233;
  arr[1] = 0x44556677;
  arr[2] = 0x8899AABB;
  arr[3] = 0xCCDDEEFF;

  printf( "\nINT array: 0x%08lX\n", (UL) arr );
  for ( i = 0; i &lt; 4; i++ ) {
    printf( "Index %d - Location: 0x%08lX  Size:%2d  Contents: 0x%08lX\n",
            i, (UL) (arr+i), (int) sizeof(int), (UL) arr[i] );
  }

  /*
    This section sets bp equal to arr.
    We may now use bp to access the array as individual bytes.
  */

  bp = (unsigned char *) arr;
  printf( "\nBYTE array: 0x%08lX\n", (UL) bp );
  for ( i = 0; i &lt; 16; i++ ) {
    printf( "Index %2d - Location: 0x%08lX  Contents: 0x%02X\n", i, (UL) (bp+i), bp[i] );
  }
  printf( "\n\n" );

  /*
    Here we first increment the character pointer by one.
  */
  arrp = (unsigned int *) ( bp + 1 );
  printf( "Original array begin: 0x%08lX\n", (UL) arr );
  printf( "Offset array begin:   0x%08lX\n", (UL) arrp );
  printf( "Byte offset:          %ld\n", ((UL)arrp)-((UL)arr) );
  for ( i = 0; i &lt; 4; i++ ) {
    printf( "Index %d - Location: 0x%08lX  Size:%2d  Contents: 0x%08lX\n",
            i, (UL) (arrp+i), (int) sizeof(int), (UL) arrp[i] );
  }
  printf( "\n" );

  return 0;
}
</pre></td></table></center><p>

What this code does is declare an array of four integers, which will be a total of 16 bytes of memory.
I then assigned a unique identifier to each of them, so they may be easily visually distinguished.
<p> 
Once the bytes are tagged, I then iterate over the array, displaying the memory location and contents of each.
This part is basic enough.
<p> 
Next, I use the <i>char*</i> to examine each individual byte of the array, printing out its address and contents.
I can use this to piece together the actual layout of the memory.
<p> 
Finally, I use the char* to offset another int*.  I then iterate over this "array" to see how the system can interpret
any four adjacent bytes as an integer.  I do not encounter a bus error.
<p> 
This was run on my toybox.  It is a 32-bit  pentium 4 with 786MB of RAM running Debian.

<pre>
Output:
INT array: <font color=darkblue>0xBFF33344</font>
<font color=darkred>Index</font> 0 - <font color=darkred>Location:</font> <font color=darkblue>0xBFF33344</font>  <font color=darkred>Size:</font> 4  <font color=darkred>Contents:</font> <font color=darkblue>0x00112233</font>
<font color=darkred>Index</font> 1 - <font color=darkred>Location:</font> <font color=darkblue>0xBFF33348</font>  <font color=darkred>Size:</font> 4  <font color=darkred>Contents:</font> <font color=darkblue>0x44556677</font>
<font color=darkred>Index</font> 2 - <font color=darkred>Location:</font> <font color=darkblue>0xBFF3334C</font>  <font color=darkred>Size:</font> 4  <font color=darkred>Contents:</font> <font color=darkblue>0x8899AABB</font>
<font color=darkred>Index</font> 3 - <font color=darkred>Location:</font> <font color=darkblue>0xBFF33350</font>  <font color=darkred>Size:</font> 4  <font color=darkred>Contents:</font> <font color=darkblue>0xCCDDEEFF</font>

BYTE array: <font color=darkblue>0xBFF33344</font>
<font color=darkred>Index</font>  0 - <font color=darkred>Location:</font> <font color=darkblue>0xBFF33344</font>  <font color=darkred>Contents:</font> <font color=darkblue>0x33</font>
<font color=darkred>Index</font>  1 - <font color=darkred>Location:</font> <font color=darkblue>0xBFF33345</font>  <font color=darkred>Contents:</font> <font color=darkblue>0x22</font>
<font color=darkred>Index</font>  2 - <font color=darkred>Location:</font> <font color=darkblue>0xBFF33346</font>  <font color=darkred>Contents:</font> <font color=darkblue>0x11</font>
<font color=darkred>Index</font>  3 - <font color=darkred>Location:</font> <font color=darkblue>0xBFF33347</font>  <font color=darkred>Contents:</font> <font color=darkblue>0x00</font>
<font color=darkred>Index</font>  4 - <font color=darkred>Location:</font> <font color=darkblue>0xBFF33348</font>  <font color=darkred>Contents:</font> <font color=darkblue>0x77</font>
<font color=darkred>Index</font>  5 - <font color=darkred>Location:</font> <font color=darkblue>0xBFF33349</font>  <font color=darkred>Contents:</font> <font color=darkblue>0x66</font>
<font color=darkred>Index</font>  6 - <font color=darkred>Location:</font> <font color=darkblue>0xBFF3334A</font>  <font color=darkred>Contents:</font> <font color=darkblue>0x55</font>
<font color=darkred>Index</font>  7 - <font color=darkred>Location:</font> <font color=darkblue>0xBFF3334B</font>  <font color=darkred>Contents:</font> <font color=darkblue>0x44</font>
<font color=darkred>Index</font>  8 - <font color=darkred>Location:</font> <font color=darkblue>0xBFF3334C</font>  <font color=darkred>Contents:</font> <font color=darkblue>0xBB</font>
<font color=darkred>Index</font>  9 - <font color=darkred>Location:</font> <font color=darkblue>0xBFF3334D</font>  <font color=darkred>Contents:</font> <font color=darkblue>0xAA</font>
<font color=darkred>Index</font> 10 - <font color=darkred>Location:</font> <font color=darkblue>0xBFF3334E</font>  <font color=darkred>Contents:</font> <font color=darkblue>0x99</font>
<font color=darkred>Index</font> 11 - <font color=darkred>Location:</font> <font color=darkblue>0xBFF3334F</font>  <font color=darkred>Contents:</font> <font color=darkblue>0x88</font>
<font color=darkred>Index</font> 12 - <font color=darkred>Location:</font> <font color=darkblue>0xBFF33350</font>  <font color=darkred>Contents:</font> <font color=darkblue>0xFF</font>
<font color=darkred>Index</font> 13 - <font color=darkred>Location:</font> <font color=darkblue>0xBFF33351</font>  <font color=darkred>Contents:</font> <font color=darkblue>0xEE</font>
<font color=darkred>Index</font> 14 - <font color=darkred>Location:</font> <font color=darkblue>0xBFF33352</font>  <font color=darkred>Contents:</font> <font color=darkblue>0xDD</font>
<font color=darkred>Index</font> 15 - <font color=darkred>Location:</font> <font color=darkblue>0xBFF33353</font>  <font color=darkred>Contents:</font> <font color=darkblue>0xCC</font>


Original array begin: <font color=darkblue>0xBFF33344</font>
Offset array begin:   <font color=darkblue>0xBFF33345</font>
Byte offset:          1
<font color=darkred>Index</font> 0 - <font color=darkred>Location:</font> <font color=darkblue>0xBFF33345</font>  <font color=darkred>Size:</font> 4  <font color=darkred>Contents:</font> <font color=darkblue>0x77001122</font>
<font color=darkred>Index</font> 1 - <font color=darkred>Location:</font> <font color=darkblue>0xBFF33349</font>  <font color=darkred>Size:</font> 4  <font color=darkred>Contents:</font> <font color=darkblue>0xBB445566</font>
<font color=darkred>Index</font> 2 - <font color=darkred>Location:</font> <font color=darkblue>0xBFF3334D</font>  <font color=darkred>Size:</font> 4  <font color=darkred>Contents:</font> <font color=darkblue>0xFF8899AA</font>
<font color=darkred>Index</font> 3 - <font color=darkred>Location:</font> <font color=darkblue>0xBFF33351</font>  <font color=darkred>Size:</font> 4  <font color=darkred>Contents:</font> <font color=darkblue>0x45CCDDEE</font>
</pre>
Analyzing this output I can draw the following diagram:
<p><center><table border=3><td><a href=endian.jpg><img src=endian.jpg width=800></a></td></table></center><p>

Each column represents an 8-bit cell in the memory.  The actual memory address of each cell is in the top column, and multiple of 4 are in bold.
Note:  The gray areas my not be system memory, but it is not memory that has been declared.
<p> 
First of note would be the middle column, in blue.  This is the array of bytes as it was initially declared and set.
<p> 
Second, we have in green the actual bytes as they lay in memory.  This is a little endian system.
<p> 
Finally, in yellow we have our 1-Byte offset array.
As you can see form the output, I neither got a seg-fault nor a bus error.  Ths single block in red is where the shifted array goes out of declared memory.
Likewise, since it does not match the tag of any declared byte, we have no idea where it came form or why it contains 0x45."
<p>
End quote -- thanks, Jay!
<hr>

<h2>Alignment within structs</h2>
<p>
<b>Malloc()</b> always returns pointers that are multiples of 8
-- therefore using <b>malloc()</b> to allocate any scalar type or
array of scalar types will generate pointers that are correctly
aligned.  
<p>
Moreover, the compiler always lays out structs so that the fields are
aligned.  Thus, in the following struct:
<pre>
struct {
  char b;
  int i;
}
</pre>
The whole struct will be 8 bytes -- 1 for <b>b</b>, 3 unused, and 4 for <b>i</b>.
The 3 bytes are necessary so that <b>i</b> will be aligned.  The compiler
does not shuffle around the fields so that they pack into memory better.
So, for example, if you have:
<pre>
struct {
  char b1;
  int i1;
  char b2;
  int i2;
}
</pre>
The struct will be 16 bytes:
<UL>
<li> 1 for <b>b1</b>
<li> 3 unused
<li> 4 for <b>i1</b>
<li> 1 for <b>b2</b>
<li> 3 unused
<li> 4 for <b>i2</b>
</UL>
<p>
However, if you order them differently, you can get all of those fields into
12 bytes:
<pre>
struct {
  char b1;
  char b2;
  int i1;
  int i2;
}
</pre>
Now the struct will have:
<UL>
<li> 1 byte for <b>b1</b>
<li> 1 byte for <b>b2</b>
<li> 2 unused bytes
<li> 4 bytes for <b>i1</b>
<li> 4 bytes for <b>i2</b>
</UL>

Finally, the following struct's size is also 8 bytes, even though you may initially think it
should only be five:

<pre>
typedef struct {
  int i;
  char b;
} S1B;
</pre>

Why?  Because if you wanted to allocate an array of ten of these using <b>malloc()</b>, you'd
do the following:

<p><center><table border=3 cellpadding=3><td><pre>
S1B *s;

s = (S1B *) malloc(sizeof(S1B)*10);
</pre></td></table></center><p>

Now, suppose <b>sizeof(S1B)</b> is only 5.  We know that <b>s</b> will be a multiple of 8
because <b>malloc()</b> guarantees that.  What about <b>&amp;(s[1])</b>?  That will be five
bytes greater than <b>s</b>, which means it won't be a multiple of 8 -- of a multiple of 4.
It is unaligned, and importantly <b>s[1].i</b> is unaligned.  By making <b>sizeof(S1B)</b>
be 8, we have no alignment problems when we use the type in an array.
<p>

The program 
<b><a href=pd.c>pd.c</a></b>
confirms all of these assertions:

<pre>
UNIX> <font color=darkred><b>pd</b></font>
8 16 12 8
UNIX> <font color=darkred><b></b></font>
</pre>


<hr>
<h2>A Common Type Bug</h2>

This looks idiotic, but it is at the heart of most type bugs.
Look at <a href=pc.c><c>pc.c</c></a>:

<p><center><table border=3 cellpadding=3><td><pre>
#include &lt;stdio.h&gt;

main()
{
  char c;
  int i;
  int j;

  i = 10000;
  c = i;
  j = c;

  printf("I: %d,   J: %d,       C: %d\n", i, j, c);
  printf("I: 0x%04x,  J: 0x%04x,   C: 0x%04x\n", i, j, c);
}
</pre></td></table></center><p>

Since <b>c</b> is a <b>char</b>, it cannot hold the value 10000.  It will
instead hold the lowest order byte of <b>i</b>, which is 16 (0x10).  Then
when you set <b>j</b> to <b>c</b>, you'll see that <b>j</b> becomes 16.
<p>
Also, even our chatty compiler doesn't complain about it.   Make sure
you understand this bug and the output below:

<pre>
UNIX> <font color=darkred><b>make pc</b></font>
gcc -g -c pc.c
gcc -g -o pc pc.o
UNIX> <font color=darkred><b>pc</b></font>
I: 10000,   J: 16,       C: 16
I: 0x2710,  J: 0x0010,   C: 0x0010
UNIX> <font color=darkred><b></b></font>
</pre>

