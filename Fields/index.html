<title>CS360 Lecture notes -- Fields</title>
<body bgcolor=ffffff>
<h1>
<a href=http://www.cs.utk.edu/~plank/plank/classes/cs360>CS360</a>
Lecture Notes -- Fields</a></h1>
<UL>
<LI><a href=http://www.cs.utk.edu/~plank>James S. Plank</a>
<LI>Directory: <b>~plank/cs360/notes/Fields</b>
<LI>Lecture notes:
    <a href=http://www.cs.utk.edu/~plank/plank/classes/cs360/360/notes/Fields>
    <b>http://www.cs.utk.edu/~plank/plank/classes/cs360/360/notes/Fields</b></a>
<LI> Original notes: Wed Aug 25 11:01:12 EDT 1999
<LI> Last Revision: 
Mon Jan 22 15:53:09 EST 2018
</UL>
<hr>

The fields library is a suite of routines that make reading input
easier than using <b>getchar()</b>, <b>scanf()</b> or <b>gets()</b>.
This is a library that I wrote -- it is not standard in Unix, but it
should work with any C compiler (this includes on DOS/Windows).
If you want to take the fields library with you after class, go 
ahead and do so.  The source code is in this repo, in the directory "Libfdr".
<p>
In order to use the fields procedures in this class, 
you should include the file
<b>fields.h</b>. 
On the EECS machines, this 
can be found in the directory 
<b>/home/plank/cs360/include</b>.  
Instead of including the full
path name in your C file, just do: 
<pre>
#include "fields.h"
</pre>
and then compile the program with:
<pre>
gcc -I/home/plank/cs360/include
</pre>
When you link your object files to make an executable, you need to
follow the directions in the <a href=../Libfdr>Libfdr</a> notes.

<p>
The 
<a href=makefile><b>makefile</b></a> 
in this directory does both of these things for you.
When you look over the file
<a href=printwords.c><b>printwords.c</b></a>,
make sure you figure out how
to compile it so that it finds <b>fields.h</b>, and so that the compilation
links with <b>libfdr.a</b>.

<hr>

The fields library defines and implements a data structure that simplifies
input processing in C.  The data structure consists of a type definition
and four procedure calls.  All are defined in <b>fields.h</b>: 

<p><center><table border=3 cellpadding=3><td><pre>
#include &lt;stdio.h&gt;
#define MAXLEN 1001
#define MAXFIELDS 1000

typedef struct inputstruct {
  char *name;               /* File name */
  FILE *f;                  /* File descriptor */
  int line;                 /* Line number */
  char text1[MAXLEN];       /* The line */
  char text2[MAXLEN];       /* Working -- contains fields */
  int NF;                   /* Number of fields */
  char *fields[MAXFIELDS];  /* Pointers to fields */
  int file;                 /* 1 for file, 0 for popen */
} *IS;

extern IS new_inputstruct(/* FILENAME -- NULL for stdin */);
extern IS pipe_inputstruct(/* COMMAND -- NULL for stdin */);
extern int get_line(/* IS */); /* returns NF, or -1 on EOF.  Does not close the file */
extern void jettison_inputstruct(/* IS */);  /* frees the IS and fcloses the file */
</pre></td></table></center><p>
To read a file with the fields library,
you call <b>new_inputstruct()</b> with the proper filename.  
<b>New_inputstruct()</b>
takes the file name as its argument (<b>NULL</b> for standard input), and
returns an <b>IS</b> as a result.  Note that the <b>IS</b> is a pointer
to a <b>struct inputstruct</b>.  This is <b>malloc()</b>'d for you 
in the <b>new_inputstruct()</b> call.  If 
<b>new_inputstruct()</b> 
cannot open the file, it will return <b>NULL</b>, and you can call
<b>perror()</b> to print out the reason for the failure (read the man
page on <b>perror()</b> if you want to learn about it).
<p>

Once you have an <b>IS</b>, you call <b>get_line()</b> on it to read a line.
<b>Get_line()</b> changes the state of the <b>IS</b> to reflect the 
reading of the line.  Specifically:
<UL>
<LI> It puts the contents of the line in <b>text1</b>.
<LI> It breaks up the line into words.  The <b>NF</b> field contains
      the number of words in the field.  The first <b>NF</b> slots
      of the <b>fields</b> array point to each of the <b>NF</b> words
      (and these words are null-terminated).
<LI> The <b>line</b> field contains the line number of the line.
<LI> <b>Get_line()</b> returns the <b>NF</b> field as its return value.
<LI> It returns -1 when it reaches the end of the file.
</UL>
<b>Jettison_inputstruct()</b> closes the file associated with the <b>IS</b>
and deallocates (frees) the <b>IS</b>.  Do not worry about 
<b>pipe_inputstruct()</b> for now. 

<p>
<hr>
These procedures are very convenient for processing input files.  For
example, the following program (in 
<a href=printwords.c><b>printwords.c</b></a>)
prints out every word of an input file prepended with its line number:

<p><center><table border=3 cellpadding=3><td><pre>
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include "fields.h"

main(int argc, char **argv)
{
  IS is;
  int i;

  if (argc != 2) {
    fprintf(stderr, "usage: printwords filename\n");
    exit(1);
  }
 
  is = new_inputstruct(argv[1]);
  if (is == NULL) {
    perror(argv[1]);
    exit(1);
  }

  while(get_line(is) &gt;= 0) {
    for (i = 0; i &lt; is-&gt;NF; i++) {
      printf("%d: %s\n", is-&gt;line, is-&gt;fields[i]);
    }
  }

  jettison_inputstruct(is);
  exit(0);
}
</pre></td></table></center><p>

So, for example, if the file <a href=rex-1.txt><b>rex-1.txt</b></a> 
contains the following three lines:

<p><center><table border=3 cellpadding=3><td><pre>
June: Hi ... I missed you!
Rex:  Same here!  You're all I could think about!
June: I was?
</pre></td></table></center><p>

Then running <b>printwords</b> on <b>rex-1.txt</b> results in the following output:

<pre>
UNIX> <font color=darkred><b>printwords rex-1.txt</b></font>
1: June:
1: Hi
1: ...
1: I
1: missed
1: you!
2: Rex:
2: Same
2: here!
2: You're
2: all
2: I
2: could
2: think
2: about!
3: June:
3: I
3: was?
UNIX>
</pre>

<hr>
One important thing to note about <b>fields.o</b> is that <i>only</i>
<b>new_inputstruct()</b> calls <b>malloc()</b>.  <b>Get_line()</b>
simply fills in the fields of the <b>IS</b> structure --- it does <i>not</i>
perform memory allocation.  Therefore, suppose you wanted to print out
the first word on the second-to-last line.  The
following program 
(<a href=badword.c><b>badword.c</b></a>)
would not work:

<p><center><table border=3 cellpadding=3><td><pre>
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include "fields.h"

int main(int argc, char **argv) 
{
  IS is;
  int i;
  char *penultimate_word;
  char *last_word;

  if (argc != 2) {
    fprintf(stderr, "usage: badword filename\n");
    exit(1);
  }
 
  is = new_inputstruct(argv[1]);
  if (is == NULL) {
    perror(argv[1]);
    exit(1);
  }

  penultimate_word = NULL;
  last_word = NULL;

  while(get_line(is) &gt;= 0) {
    penultimate_word = last_word;
    if (is-&gt;NF &gt; 0) {
      last_word = is-&gt;fields[0];  <font color=blue>/* This doesn't make a copy of the word. */</font>
    } else {
      last_word = NULL;
    }
  }

  if (penultimate_word != NULL) printf("%s\n", penultimate_word);
  jettison_inputstruct(is);
  exit(0);
}
</pre></td></table></center><p>

Why?  Look at what happens when you execute it on </b>rex-1.txt</b>:

<pre>
UNIX> <font color=darkred><b>badword rex-1.txt</b></font>
June:
UNIX>
</pre>

It prints ``June:'' instead of ``Rex:'' because <b>get_line()</b>
does not allocate any new memory.  Both <b>penultimate_word</b> and 
<b>last_word</b> end up pointing to the same thing.   
<p>
Let's try another example which is probably a little more confusing:

<pre>
UNIX> <font color=darkred><b>cat rex-2.txt</b></font>
June: Hi ... I missed you!
  Rex:  Same here!  You're all I could think about!
June: I was?
UNIX> <font color=darkred><b>badword rex-2.txt</b></font>
ne:
UNIX> <font color=darkred><b></b></font>
</pre>

Remember, <b>get_line()</b> doesn't call <b>malloc()</b>.  <b>Malloc()</b> is only called
in <b>new_inputstruct()</b>.  The <b>fields</b> pointers point to memory which is in
the <b>text2</b> part of the struct.  Thus, if the first word is the first character
on the line, then <b>is->fields[0]</b> points to <b>is->text2</b>.  If the first word is
the third character on the line, then <b>is->fields[0]</b> points to <b>is->text2+2</b>.
That is why the "ne:" is printed -- because <b>penultimate_line</b> points to <b>is->text2+2</b>.
Since <b>is->text2</b> has been overwritten with <b>"June:"</b> in the <b>get_line()</b> call,
<b>penultimate_line</b> points to "ne:".
<p>


Make sure you understand
this example, because you can get yourself into a mess of trouble otherwise.
If you're still having problems, put in some print statements and print out the 
addresses of the pointers.
<p>
The correct version of the program is in 
<a href=goodword.c><b>goodword.c</b></a>:
(note that this
is a very inefficient program because of all the <b>strdup()</b> and 
<b>free()</b> calls.  You could do better if you wanted to.

<p><center><table border=3 cellpadding=3><td><pre>
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include "fields.h"

int main(int argc, char **argv)
{
  IS is;
  int i;
  char *penultimate_word;
  char *last_word;

  if (argc != 2) {
    fprintf(stderr, "usage: badword filename\n");
    exit(1);
  }
 
  is = new_inputstruct(argv[1]);
  if (is == NULL) {
    perror(argv[1]);
    exit(1);
  }

  penultimate_word = NULL;
  last_word = NULL;

  while(get_line(is) &gt;= 0) {
    if (penultimate_word != NULL) {  <font color=blue>/* This prevents you from having a memory leak. */</font>
      free(penultimate_word);
    }
    penultimate_word = last_word;
    if (is-&gt;NF &gt; 0) {
      last_word = strdup(is-&gt;fields[0]);  <font color=blue>/* This does make a copy of the word. */</font>
    } else {
      last_word = NULL;
    }
  }

  if (penultimate_word != NULL) printf("%s\n", penultimate_word);
  jettison_inputstruct(is);
  exit(0);
}
</pre></td></table></center><p>


<b>Field.o</b> assumes that all input lines are less than 1000 characters.

<hr>
<h2>tailanyf</h2>

Now, as another example, 
<a href=tailanyf.c><b>tailanyf.c</b></a>
takes <i>n</i> as a command line argument, and prints out the last <i>n</i>
lines of standard input.  It uses the fields library to read standard input.

<hr>
<h2>pipe_inputstruct()</h2>

This lets you read from a pipe that gets opened with <b>popen()</b>.
The program 
<b><a href=pipetest.c>pipetest.c</a></b>
uses <b>pipe_inputstruct()</b> to 
count the number of lines in all the <b>.c</b> files in the  
It does this by using <b>pipe_inputstruct()</b> to get
the standard output of 'cat *.c' into an <b>inputstruct</b>:

<p><center><table border=3 cellpadding=3><td><pre>
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include "fields.h"

int main()
{
  IS is;
  int nlines;

  is = pipe_inputstruct("cat *.c");
  if (is == NULL) { perror("cat *.c"); exit(1); }

  nlines = 0;
  while (get_line(is) &gt;= 0) nlines++;

  printf("# lines in *.c: %d\n", nlines);
  exit(0);
}
</pre></td></table></center><p>
